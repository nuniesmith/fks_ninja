# NinjaTrader Desktop SDK Documentation

Captured on: 2025-07-07T18:22:17.220Z

Total pages: 88

---

## Table of Contents

1. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop)
2. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/ninjascript_best_practices)
3. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/commercial_distribution)
4. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/best_practices)
5. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/best_practices)
6. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/licensing_user_authentication)
7. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/distribution_procedure)
8. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/considerations_for_compiled_assemblies)
9. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/import)
10. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/export)
11. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/remove_ninjascript_assembly)
12. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/export_problems)
13. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/protection_dll_security)
14. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/ninjascript_editor_overview)
15. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compile_error_codes)
16. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/ninjascript_editor_components)
17. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/ninjascript_explorer)
18. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/ninjascript_wizard)
19. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/code_snippets)
20. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compile_errors)
21. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/intelliprompt)
22. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/output_window)
23. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/visual_studio_debugging)
24. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/editor_keyboard_shortcuts)
25. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/creating_your_own_addon_window)
26. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/creating_your_own_addon_window)
27. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/developing_add_ons)
28. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/other_uses_for_an_addon)
29. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/c_method_functions_reference)
30. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/developing_for_tick_replay)
31. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/developing_outside_of_the_ninj)
32. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/set_up9)
33. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic6)
34. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling6)
35. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using6)
36. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/set_up8)
37. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic5)
38. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling5)
39. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using5)
40. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/set_up7)
41. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic4)
42. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling4)
43. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using4)
44. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic3)
45. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic3)
46. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling3)
47. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using3)
48. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic2)
49. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic2)
50. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling2)
51. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using2)
52. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic)
53. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic)
54. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling)
55. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using)
56. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/set_up11)
57. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/entering_strategy_logic)
58. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/compiling8)
59. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/the_strategy_development_process)
60. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/working_with_accounts)
61. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/historical_order_backfill_logic)
62. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/multi_threading_consideration_for_ninjascript)
63. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/multi_time_frame_instruments)
64. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/understanding_the_lifecycle_of)
65. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_3rd_party_indicators)
66. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_atm_strategies)
67. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_bitmapimage_objects_with_buttons)
68. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_historical_bid_ask_serie)
69. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_images_and_geometry_with_custom_icons)
70. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/using_sharpdx_for_custom_chart_rendering)
71. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/working_with_brushes)
72. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/working_with_chart_object_coordinates)
73. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/working_with_pixel_coordinates)
74. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/working_with_price_series)
75. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/reference_samples)
76. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/calculating_the_highest_high_or_lowest_low_for_a_specified_time_range)
77. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/adddataseries)
78. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addheikenashi)
79. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addheikenashi)
80. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addkagi)
81. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addlinebreak)
82. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addpointandfigure)
83. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addrenko)
84. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/addvolumetric)
85. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/barsarray)
86. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/barsinprogress)
87. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/barsperiods)
88. [NinjaTrader Developer Community | NinjaScript Resources & Documentation](https://developer.ninjatrader.com/docs/desktop/currentbars)

---

## 1. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop

**Captured:** 2025-07-07T18:15:19.344Z

### Page Structure

- Introduction
  - What is NinjaScript?
  - Why Develop with NinjaScript?
  - What You'll Learn
  - Prerequisites
  - Getting Started
  - Support and Resources
      - ON THIS PAGE
- Introduction
  - What is NinjaScript?
  - Why Develop with NinjaScript?
  - What You'll Learn
  - Prerequisites
  - Getting Started
  - Support and Resources
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXIntroductionWelcome to the NinjaTrader NinjaScript Documentation. This comprehensive guide is designed to help you harness the full power of NinjaScript, NinjaTrader's powerful C#-based trading programming language. Whether you're looking to develop custom indicators, automate trading strategies, or create new trading tools, this documentation will provide you with the knowledge and resources to bring your ideas to life.What is NinjaScript?NinjaScript is a robust programming language built on C# that allows you to create custom technical indicators, strategies, drawing tools, and more within the NinjaTrader platform. It offers a rich set of classes and methods specifically tailored for financial market analysis and trading system development.Why Develop with NinjaScript?By developing with NinjaScript, you can:Customize Your Trading Experience: Tailor the NinjaTrader platform to fit your unique trading style and strategies.Automate Trading Strategies: Develop automated systems that execute trades based on predefined criteria.Create Advanced Indicators: Build proprietary indicators to gain deeper insights into market movements.Enhance Efficiency: Automate repetitive tasks and streamline your trading workflow.What You'll LearnIn this documentation, you'll discover:Getting Started with NinjaScript: Setting up your development environment and understanding the basics.Creating Custom Indicators: Developing indicators that analyze market data and provide visual cues.Building Automated Strategies: Crafting strategies that execute trades automatically based on your algorithms.Advanced Programming Concepts: Exploring topics like optimization, backtesting, and performance considerations.Debugging and Testing: Utilizing debugging tools to test and refine your code for optimal performance.Best Practices: Guidelines to write efficient, maintainable, and robust NinjaScript code.PrerequisitesTo get the most out of this documentation, you should have:Basic Understanding of C#: Familiarity with C# programming will help you grasp NinjaScript concepts more effectively.NinjaTrader Platform Installed: Ensure you have the NinjaTrader Desktop platform installed on your computer.Access to Development Tools: We'll guide you on how to use the NinjaScript Editor and other essential tools within NinjaTrader.Getting StartedReady to embark on your NinjaScript development journey? Start with our beginner-friendly tutorials and gradually progress to more advanced topics. Here's how to begin:Set Up Your Environment: Learn how to access the NinjaScript Editor and configure your settings.Understand the Basics: Familiarize yourself with the NinjaScript architecture, syntax, and key concepts.Create Your First Indicator: Follow a step-by-step guide to build a simple custom indicator.Explore Sample Code: Access a library of sample scripts to learn from practical examples.Support and ResourcesWe're here to support you every step of the way:Documentation: Access detailed NinjaScript Reference SamplesCommunity Forums: Join the NinjaTrader Support Forum to ask questions, share ideas, and connect with other developers.Support Team: Contact our support team for personalized assistance with your projects [NinjaTrader Support] (https://support.ninjatrader.com/s/?language=en_US)ON THIS PAGEWhat is NinjaScriptWhy Develop with NinjaScriptWhat You'll LearnPrerequisitesGetting StartedSupport and ResourcesIntroductionWelcome to the NinjaTrader NinjaScript Documentation. This comprehensive guide is designed to help you harness the full power of NinjaScript, NinjaTrader's powerful C#-based trading programming language. Whether you're looking to develop custom indicators, automate trading strategies, or create new trading tools, this documentation will provide you with the knowledge and resources to bring your ideas to life.What is NinjaScript?NinjaScript is a robust programming language built on C# that allows you to create custom technical indicators, strategies, drawing tools, and more within the NinjaTrader platform. It offers a rich set of classes and methods specifically tailored for financial market analysis and trading system development.Why Develop with NinjaScript?By developing with NinjaScript, you can:Customize Your Trading Experience: Tailor the NinjaTrader platform to fit your unique trading style and strategies.Automate Trading Strategies: Develop automated systems that execute trades based on predefined criteria.Create Advanced Indicators: Build proprietary indicators to gain deeper insights into market movements.Enhance Efficiency: Automate repetitive tasks and streamline your trading workflow.What You'll LearnIn this documentation, 

[Content truncated...]


---

## 2. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/ninjascript_best_practices

**Captured:** 2025-07-07T18:15:33.384Z

### Page Structure

- NinjaScript Best Practices
  - Note
  - State management practices
    - Managing Resources
    - Setting Default UI Property Grid values
  - Note
    - Calculating run-time object values
    - Setting class level variables
    - Resetting class level variables for Strategy Analyzer Optimization
    - Accessing properties related to market data
  - Note
    - Setting up resources that rely on market data
    - Accessing element on the UI
    - Transitioning order references from historical to real-time
    - Terminating custom resources
  - Error handling practices
    - Safely accessing reference objects
    - Accessing objects which terminate
    - Proving instructions for non-ninjascript properties
    - Modifying UI elements and multi-threading
  - Warning
    - Properly implementing try/catch blocks
    - Using WPF brushes
    - barsAgo indexer vs. absolute bar Index
    - Casting safely
  - Performance practices
    - Referencing indicator methods
  - Warning
    - Marking object references for garbage collection
  - Note
    - Disposing of custom resources
  - Note
    - Avoiding duplicate calculations
    - Caching values on bars which remove last bar
    - Precomputing values instead of calculating in OnRender()
    - Restricting OnRender() calculations to visible ChartBars
    - Using DrawObjects vs custom graphics in OnRender()
  - Note
    - Responding to user events
    - Delaying logic for a particular time interval
  - Miscellaneous practices
    - Floating-point comparison
    - Creating user defined parameter types / enums
    - Efficiently debugging
    - Debug Mode
    - Known NinjaScript Wrappers limitations
      - ON THIS PAGE
- NinjaScript Best Practices
  - Note
  - State management practices
    - Managing Resources
    - Setting Default UI Property Grid values
  - Note
    - Calculating run-time object values
    - Setting class level variables
    - Resetting class level variables for Strategy Analyzer Optimization
    - Accessing properties related to market data
  - Note
    - Setting up resources that rely on market data
    - Accessing element on the UI
    - Transitioning order references from historical to real-time
    - Terminating custom resources
  - Error handling practices
    - Safely accessing reference objects
    - Accessing objects which terminate
    - Proving instructions for non-ninjascript properties
    - Modifying UI elements and multi-threading
  - Warning
    - Properly implementing try/catch blocks
    - Using WPF brushes
    - barsAgo indexer vs. absolute bar Index
    - Casting safely
  - Performance practices
    - Referencing indicator methods
  - Warning
    - Marking object references for garbage collection
  - Note
    - Disposing of custom resources
  - Note
    - Avoiding duplicate calculations
    - Caching values on bars which remove last bar
    - Precomputing values instead of calculating in OnRender()
    - Restricting OnRender() calculations to visible ChartBars
    - Using DrawObjects vs custom graphics in OnRender()
  - Note
    - Responding to user events
    - Delaying logic for a particular time interval
  - Miscellaneous practices
    - Floating-point comparison
    - Creating user defined parameter types / enums
    - Efficiently debugging
    - Debug Mode
    - Known NinjaScript Wrappers limitations
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript Best PracticesThere are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.NoteNinjaTrader is multi-threaded and event driven. Always assume that any of the methods you implement in NinjaScript could be called from another thread.State management practicesManaging ResourcesThe OnStateChange() method is called anytime there has been a change of State and can be used to help you setup, manage, and destroy several types of resources. Where these values are setup is highly dependent on the kind of resource you are using. The section below will cover how to manage various resources throughout different states.Setting Default UI Property Grid valuesReserve State.SetDefaults for defaulting any public properties you wish to have exposed on the UI property grid. You should also use this State for setting default desired NinjaScript property behavior which can be overridden from the property grid (e.g. Calculate, IsOverlay, etc.). For Plots and Lines you wish to configure, AddPlot(), AddLine() should also have their default values set during this State.WhyPublic values of the NinjaScript object in SetDefaults are pushed to the UI property grid for an opportunity to change settings of your object.// Best practice
protected override void OnStateChange()
{
   // these are the values that show up as default on the UI
   if (State == State.SetDefaults)
   {
     Calculate = Calculate.OnPriceChange;
     IsOverlay = false;

     Period = 50;

     AddPlot(Brushes.Blue, "Plot Value");
     AddLine(Brushes.Gray, 100, "Threshold");
   }

For public properties you do NOT wish exposed to the UI property grid, set the Browsable attribute to false:// Best practice
[Browsable(false)] // prevents from showing up on the UI property grid
public int Communicator { get; set; 
On indicators, properties you wish to set from other objects, set the NinjaScriptPropertyAttribute:// Best practice
[NinjaScriptProperty] // can now call **MyIndicator**(20) from another object
public int Period { get; set; }
The default behavior is to serialize any public properties and fields to a Workspace or Template file when saving. However, not all objects can be serialized - or you may wish to exclude a property from being saved and restored. For these scenarios, set the XmlIgnore attribute to the property:// Best practice
[XmlIgnore] // removes from serialization
public Brush DownBrush
{ get; set; }
As a best practice as well, your NinjaScript should not have any public fields, since those would get serialized as well - which means their state would be persisted, which in turn could lead to unexpected outcomes.NoteSee the Working with Brushes section of the Help Guide for information on properly serializing brushes.Calculating run-time object valuesDo not attempt to do advanced calculations or try to access object references in State.SetDefaults. This State should be kept as lean as possible, and any calculation logic should be delayed until at least State.Configure.WhyYour object will be called in situations you may not be expecting. You can read more about this subject on Understanding the life cycle of your NinjaScript objects.// Practice to avoid
protected override void OnStateChange()
{
   if (State == State.SetDefaults)
   {
       // logic could take longer than desired as the list of indicator names is populated
       for (int i = 0; i <= array.length; i++)
           DoWork(i);

       // possible null reference exception since **TickSize** is not set yet
       Period = 5 * TickSize;
   }
// Best practice
protected override void OnStateChange()
{
   // Complex operations should be delayed to >= State.Configure
   if (State == State.Configure)
   {
       for (int i = 0; i <= array.length; i++)
           DoWork(i);
   }

   // information related to market data is not available until at least State.DataLoaded
   else if (State == State.DataLoaded)
   {
       Period = 5 * TickSize;
   }
}
Setting class level variablesDo not set variables at the class level unless they are constant. You should delay setting or resetting variables until the State has reached State.Configure. You can use const keyword to differentiate values which do not change from variables which do change.WhyWaiting to set up and define resources until the object has been configured ensures that values not set up and declared prematurely.// Best practice
// value is always 5, it can be made constant and declared at the class level
private const int multiplier = 5;

// these values can change, may be better t

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Best practice
protected override void OnStateChange()
{
   // these are the values that show up as default on the UI
   if (State == State.SetDefaults)
   {
     Calculate = Calculate.OnPriceChange;
     IsOverlay = false;

     Period = 50;

     AddPlot(Brushes.Blue, "Plot Value");
     AddLine(Brushes.Gray, 100, "Threshold");
   }
```

#### Example 2

```csharp
// Best practice
protected override void OnStateChange()
{
   // these are the values that show up as default on the UI
   if (State == State.SetDefaults)
   {
     Calculate = Calculate.OnPriceChange;
     IsOverlay = false;

     Period = 50;

     AddPlot(Brushes.Blue, "Plot Value");
     AddLine(Brushes.Gray, 100, "Threshold");
   }
```

#### Example 3

```csharp
// Best practice
[Browsable(false)] // prevents from showing up on the UI property grid
public int Communicator { get; set;
```

---

## 3. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/commercial_distribution

**Captured:** 2025-07-07T18:15:48.352Z

### Page Structure

- Commercial Distribution
  - Commercial Distribution Overview
      - ON THIS PAGE
- Commercial Distribution
  - Commercial Distribution Overview
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCommercial DistributionCommercial Distribution OverviewAs a commercial developer, you can distribute your proprietary indicators and strategies to the growing universe of NinjaTrader users. This section contains information you should understand before distributing your work to the public.Licensing/User AuthenticationBest PracticesDistribution ProcedureON THIS PAGECommercial Distribution OverviewCommercial DistributionCommercial Distribution OverviewAs a commercial developer, you can distribute your proprietary indicators and strategies to the growing universe of NinjaTrader users. This section contains information you should understand before distributing your work to the public.Licensing/User AuthenticationBest PracticesDistribution ProcedureON THIS PAGECommercial Distribution Overview

---

## 4. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/best_practices

**Captured:** 2025-07-07T18:15:50.354Z

### Page Structure

- Best Practices for Distribution
  - Do not deploy NinjaScript Source Files
  - Naming Conventions
  - Clean up your resources
  - User Authentication Trigger
  - User Authentication Check State
  - User Authentication Time Out
  - Custom Installer
  - Test on Legacy Operating Systems
  - Expose Indicator States
      - ON THIS PAGE
- Best Practices for Distribution
  - Do not deploy NinjaScript Source Files
  - Naming Conventions
  - Clean up your resources
  - User Authentication Trigger
  - User Authentication Check State
  - User Authentication Time Out
  - Custom Installer
  - Test on Legacy Operating Systems
  - Expose Indicator States
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXBest Practices for DistributionThe following are what we suggest for best practices for distribution.Do not deploy NinjaScript Source FilesIf you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.Naming ConventionsPlease use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.Clean up your resourcesAlways free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.User Authentication TriggerIf you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.User Authentication Check StateA license check should only be performed once and maintain its check state.User Authentication Time OutA license check should have a time out in case of internet issues, to enhance performance in this case.Custom InstallerIf you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.These are the following folder names:Documents\NinjaTrader 7\bin\CustomDocuments\NinjaTrader 8\bin\CustomTest on Legacy Operating SystemsSome NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.Expose Indicator StatesIf your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.ON THIS PAGEDo not deploy NinjaScript Source FilesNaming ConventionsClean up your resourcesUser Authentication TriggerUser Authentication Check StateUser Authentication Time OutCustom InstallerTest on Legacy Operating SystemsExpose Indicator StatesBest Practices for DistributionThe following are what we suggest for best practices for distribution.Do not deploy NinjaScript Source FilesIf you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.Naming ConventionsPlease use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader

[Content truncated...]


### Code Examples

#### Example 1

```csharp
Documents\NinjaTrader 7\bin\Custom
```

#### Example 2

```csharp
Documents\NinjaTrader 8\bin\Custom
```

#### Example 3

```csharp
Documents\NinjaTrader 7\bin\Custom
```

---

## 5. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/best_practices

**Captured:** 2025-07-07T18:15:52.347Z

### Page Structure

- Best Practices for Distribution
  - Do not deploy NinjaScript Source Files
  - Naming Conventions
  - Clean up your resources
  - User Authentication Trigger
  - User Authentication Check State
  - User Authentication Time Out
  - Custom Installer
  - Test on Legacy Operating Systems
  - Expose Indicator States
      - ON THIS PAGE
- Best Practices for Distribution
  - Do not deploy NinjaScript Source Files
  - Naming Conventions
  - Clean up your resources
  - User Authentication Trigger
  - User Authentication Check State
  - User Authentication Time Out
  - Custom Installer
  - Test on Legacy Operating Systems
  - Expose Indicator States
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXBest Practices for DistributionThe following are what we suggest for best practices for distribution.Do not deploy NinjaScript Source FilesIf you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.Naming ConventionsPlease use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.Clean up your resourcesAlways free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.User Authentication TriggerIf you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.User Authentication Check StateA license check should only be performed once and maintain its check state.User Authentication Time OutA license check should have a time out in case of internet issues, to enhance performance in this case.Custom InstallerIf you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.These are the following folder names:Documents\NinjaTrader 7\bin\CustomDocuments\NinjaTrader 8\bin\CustomTest on Legacy Operating SystemsSome NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.Expose Indicator StatesIf your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.ON THIS PAGEDo not deploy NinjaScript Source FilesNaming ConventionsClean up your resourcesUser Authentication TriggerUser Authentication Check StateUser Authentication Time OutCustom InstallerTest on Legacy Operating SystemsExpose Indicator StatesBest Practices for DistributionThe following are what we suggest for best practices for distribution.Do not deploy NinjaScript Source FilesIf you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.Naming ConventionsPlease use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader

[Content truncated...]


### Code Examples

#### Example 1

```csharp
Documents\NinjaTrader 7\bin\Custom
```

#### Example 2

```csharp
Documents\NinjaTrader 8\bin\Custom
```

#### Example 3

```csharp
Documents\NinjaTrader 7\bin\Custom
```

---

## 6. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/licensing_user_authentication

**Captured:** 2025-07-07T18:15:56.350Z

### Page Structure

- Licensing User Authentication
  - Licensing/User Authentication
      - ON THIS PAGE
- Licensing User Authentication
  - Licensing/User Authentication
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXLicensing User AuthenticationLicensing/User AuthenticationNinjaTrader provides a free vendor license management service for user authentication to qualified 3rd party developers.The service includes the following features:One method call within your NinjaScript indicator or strategy's constructor will enable the authentication processA NinjaScript AddOn dedicated to license management (Manage license, provide free trials)Licenses are exclusively tied to a combination of user-defined prefix + PC machine ID value, ensuring that licenses cannot be sharedManage all of your individual products, or group products together for licensingLicenses expire based on time/dateCreate free trial periodsFor more information please contact info@ninjatraderecosystem.com or your NinjaTrader Business Development representative. Once approved, you will receive a unique Vendor ID used to manage your user licenses, a Vendor Licensing Help Guide containing information, samples, and resources to guide you through the process of managing licensing.ON THIS PAGELicensing/User AuthenticationLicensing User AuthenticationLicensing/User AuthenticationNinjaTrader provides a free vendor license management service for user authentication to qualified 3rd party developers.The service includes the following features:One method call within your NinjaScript indicator or strategy's constructor will enable the authentication processA NinjaScript AddOn dedicated to license management (Manage license, provide free trials)Licenses are exclusively tied to a combination of user-defined prefix + PC machine ID value, ensuring that licenses cannot be sharedManage all of your individual products, or group products together for licensingLicenses expire based on time/dateCreate free trial periodsFor more information please contact info@ninjatraderecosystem.com or your NinjaTrader Business Development representative. Once approved, you will receive a unique Vendor ID used to manage your user licenses, a Vendor Licensing Help Guide containing information, samples, and resources to guide you through the process of managing licensing.ON THIS PAGELicensing/User Authentication

---

## 7. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/distribution_procedure

**Captured:** 2025-07-07T18:16:00.360Z

### Page Structure

- Distribution Procedure
  - Creating the distribution package
  - Warning
    - Adding custom assemblies or native DLLs
  - Note
    - Adding templates
    - Adding workspaces
    - Adding custom resource files
  - Note
      - ON THIS PAGE
- Distribution Procedure
  - Creating the distribution package
  - Warning
    - Adding custom assemblies or native DLLs
  - Note
    - Adding templates
    - Adding workspaces
    - Adding custom resource files
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXDistribution ProcedureNinjaTrader makes it easy to distribute complete packages for your clients. Not only can you distribute your indicators and strategies, but you can also seamlessly deploy your own custom assemblies, native DLLs, chart templates, and Market Analyzer templates to your clients.Creating the distribution packageTo create a distribution package, please follow the steps shown here for creating a Export file containing your NinjaScript indicators and/or strategies.It is strongly recommended that you export your scripts as an assembly and use SecureTeam's Agile.NET. Only this process will provide you with the highest level of security possible in order to protect your intellectual property. For more information on using SecureTeam's Agile.NET please see the Protection/DLL Security section.After you finish using the Export utility you will find the distribution package as a .zip file located in My Documents\NinjaTrader 8\bin\Custom\ExportNinjaScript. If you only wanted to distribute your NinjaScript files then providing your customers with this .zip and having them go through the Import process would install it on their machines. If you wish to add more custom files to your distribution package, please see the sections below.WarningIt is important to let your customers know that NinjaTrader 8 indicators and strategies are NOT necessarily compatible with NinjaTrader Version 7.Adding custom assemblies or native DLLsLocate your base .zip distribution packageOpen the .zipAdd to the .zip file your assemblies and/or your DLL files to the root directory of the .zip. These files cannot be behind any extra directory structures and must be directly in the root of the .zipFor custom assemblies, you will also need to add to the root of the .zip a .txt file called AdditionalReferences.txt:Bring up the Windows Start MenuGo to the Run field and type "notepad" without the quotes and press EnterIn Notepad, type the name of your custom assembly and then save the file as a text file with the name "AdditionalReferences".Ex: If your custom assembly's name was MyCustomAssembly.dll and MyCustomAssembly.cs, in the AdditionalReferences.txt file you would type "MyCustomAssembly" without the quotes.NoteIf you have multiple custom assemblies to add you can append each of the assembly's names into the same AdditionalReferences.txt file on new linesAdding templatesIf you are distributing an indicator package, you may also want to distribute a prebuilt Chart Template that your customers can use to quickly bring up preferred settings for your chart setup. The same instructions here would work though for all other templates as well, i.e. MarketAnalyzer, DrawingTools - as long as the relative folder under templates is correctly set per the template category you're working with. The below steps run through the process for Chart templates.Locate your base .zip distribution packageOpen the .zipCreate a new directory called "templates" without the quotesNavigate into the "templates" directory and create another new directory called "Chart"Navigate into the "Chart" directory. Copy the .xml chart templates you wish to distribute from My Documents\NinjaTrader 8\templates\Chart to this directory in the .zipAdding workspacesIf you are distributing an indicator package, you may also want to distribute a prebuilt Workspace that your customers can use to quickly bring up preferred settings for your workspace. The below steps run through the process for workspaces.Locate your base .zip distribution packageOpen the .zipCreate a new directory called "workspaces" without the quotesNavigate into the "workspaces" directory. Copy the .xml workspace you wish to distribute from My Documents\NinjaTrader 8\workspaces to this directory in the .zipAdding custom resource filesYou may run into the need to distribute other custom files such as pictures for buttons for use with your product as well. This can be achieved via the same approach as for the templates, as long as the resources folder is under the parent templates directory.Locate your base .zip distribution packageOpen the .zipCreate a new directory called "templates" without the quotesNavigate into the "templates" directory and create another new directory, for example "MyResources"Navigate to the directory where your files are stored. Copy the resource files you wish to distribute from this directory to your custom directory from step 4 in the .zipNoteWhen modifying

[Content truncated...]


---

## 8. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/considerations_for_compiled_assemblies

**Captured:** 2025-07-07T18:16:04.355Z

### Page Structure

- Considerations for Compiled Assemblies
  - Using Compiled Assemblies
  - Using Custom enum Properties
  - Casting Types in a DLL (Using dynamic Types)
  - Working with the dynamic type
  - Adding XAML and Other Files Into a DLL
  - Exporting custom drawing tools as assembly / DLL
  - Warning
  - Exports might not be backwards compatible
      - ON THIS PAGE
- Considerations for Compiled Assemblies
  - Using Compiled Assemblies
  - Using Custom enum Properties
  - Casting Types in a DLL (Using dynamic Types)
  - Working with the dynamic type
  - Adding XAML and Other Files Into a DLL
  - Exporting custom drawing tools as assembly / DLL
  - Warning
  - Exports might not be backwards compatible
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXConsiderations for Compiled AssembliesUsing Compiled AssembliesCompiled assemblies (DLL's) allow you to bundle your scripts into a format that hides your proprietary code along with any supporting resources. Compiled assemblies provide distinct benefits, especially for commercially distributed code, but there are a few considerations to keep in mind. Typecasting and building resource files (sounds, images, etc.) into your assemblies must be approached differently to ensure cleanly packaged, error-free DLL's.Using Custom enum PropertiesWhen creating custom enum properties, it is advised to create the enum outside of your NinjaScript class, and designating it in its own fully qualified namespace. For an example, please see here. When using the enum in code, please use the fully qualified namespace as opposed to using a using directive to shorthand the expression.Casting Types in a DLL (Using dynamic Types)Sometimes, you may need to cast your objects to NinjaScript types, such as when iterating through the DrawObjects collection to obtain a reference to a particular Drawing Object on a chart. When running C# code which has not been compiled into an assembly, typecasting can be done normally, as in the example below:// Typecasting in code outside of a compiled assembly

protected override void OnBarUpdate()
{
   foreach(HorizontalLine line in DrawObjects)
   {
       // Print the tag of each Horizontal Line on the chart
       Print(String.Format("Horizontal Line {0} found.", line.Tag));
   }
}
An obstacle arises with traditional typecasting in a compiled assembly, since the NinjaScript type you attempt to cast will be present in both your DLL and NinjaTrader's Custom.dll assembly. If you plan to compile your code into a DLL, you will need to use the dynamic type to avoid this conflict by dynamically assigning the type at runtime, using the guidelines below:Loop through your collection using the interface typeUse ToString() to check the fully qualified namespace of the object in the loopCast the object to dynamic, and reference properties of that object assuming it is the expected typeforeach (IDrawingTool line in DrawObjects.ToList())
{
   // Use ToString().Equals() to detect the object's Type
   if (line.ToString().Equals("NinjaTrader.NinjaScript.DrawingTools.HorizontalLine"))
   {
       // Cast line as dynamic and access the object by assuming that it is the Type we expect
       Print(String.Format("Horizontal Line {0} detected!", (line as dynamic).Tag));
   }
}
The above dynamic approach will work for primitive types. For instantiating more complex types / classes though, such as adding a new PriceLevel programmatically to an existing drawing tool, Reflection would need to be used.// Instantiating more complex types such as the PriceLevels class inside of a compiled assembly

foreach (dynamic dt in DrawObjects.ToList())
{
   if(dt.ToString().Equals("NinjaTrader.NinjaScript.DrawingTools.FibonacciRetracements"))
   {
     Type type         = dt.PriceLevels.GetType().GetGenericArguments()[0];
     Assembly assembly = type.Assembly;
     var pl           = assembly.CreateInstance(type.FullName, false, BindingFlags.CreateInstance, null, new object[] { 55.5, Brushes.Red, 2 }, new System.Globalization.CultureInfo("en-US"), new object[] {});
     dt.PriceLevels.GetType().GetMethod("Add").Invoke(dt.PriceLevels, new object[] { pl });
     this.ForceRefresh();
   }
}
Working with the dynamic typeUsing dynamic variables in the technique above requires careful attention to accessing members appropriately, and thus should be avoided if you do not intend to use or distribute compiled assemblies.No Intelliprompt: Since the compiler cannot know which type you assume a dynamic variable to be, no Intelliprompt will be displayed to help search through type members. The same applies to Visual Studio's Intellisense or similar utilities.No Compile Errors: For the same reason, the compiler cannot know if you are using the variable in a way not supported by its expected type, trying to access members not present in that type, or other related errors. Thus, any such errors which would be caught by the compiler when typecasting will be missed, and will result in runtime errors instead. If a runtime error were to be triggered, the error may be more difficult to interpret.Example: If you tried to access line.tag (improper capitalization) in the examples above, you would receive the following errors:Typeca

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Typecasting in code outside of a compiled assembly

protected override void OnBarUpdate()
{
   foreach(HorizontalLine line in DrawObjects)
   {
       // Print the tag of each Horizontal Line on the chart
       Print(String.Format("Horizontal Line {0} found.", line.Tag));
   }
}
```

#### Example 2

```csharp
// Typecasting in code outside of a compiled assembly

protected override void OnBarUpdate()
{
   foreach(HorizontalLine line in DrawObjects)
   {
       // Print the tag of each Horizontal Line on the chart
       Print(String.Format("Horizontal Line {0} found.", line.Tag));
   }
}
```

#### Example 3

```csharp
foreach (IDrawingTool line in DrawObjects.ToList())
{
   // Use ToString().Equals() to detect the object's Type
   if (line.ToString().Equals("NinjaTrader.NinjaScript.DrawingTools.HorizontalLine"))
   {
       // Cast line as dynamic and access the object by assuming that it is the Type we expect
       Print(String.Format("Horizontal Line {0} detected!", (line as dynamic).Tag));
   }
}
```

---

## 9. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/import

**Captured:** 2025-07-07T18:16:07.356Z

### Page Structure

- Import
      - ON THIS PAGE
- Import
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXImportYou should only import NinjaScript Archive files (.zip) that you have obtained from a trusted source.To import:From the Control Center window select the menu Tools > Import > NinjaScript... to open the "Import" dialog window.Select the file you want to import.Press the Import button.ON THIS PAGEImportYou should only import NinjaScript Archive files (.zip) that you have obtained from a trusted source.To import:From the Control Center window select the menu Tools > Import > NinjaScript... to open the "Import" dialog window.Select the file you want to import.Press the Import button.ON THIS PAGE

---

## 10. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/export

**Captured:** 2025-07-07T18:16:10.360Z

### Page Structure

- Export
  - Exporting NinjaScript as Source Files
  - Exporting NinjaScript as Assembly
  - Note
      - ON THIS PAGE
- Export
  - Exporting NinjaScript as Source Files
  - Exporting NinjaScript as Assembly
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXExportYou can export NinjaScript for others to import in several formats:Source files - NinjaScript source files that can be imported and edited by others.Assemblies - A compiled assembly (DLL) of NinjaScript that "hides" your source code. This can be further protected by SecureTeam's Agile.NET to prevent theft of your intellectual property.Exporting NinjaScript as Source FilesYou may want to provide other NinjaTrader users with source files of your NinjaScript in a format where they are able to view and edit them.From the Control Center window select the menu Tools > Export > NinjaScript... to open the "Export NinjaScript" dialog window.Press "add".Use the "Type" drop down to filter available NinjaScript types.Select all of the files that you want to export and press the "OK" button.A list of all files that will be exported will be shown.Press the "Export" button to export the selected files.A file dialog will open where you can choose the location your zip export file will be created in. Per default the NinjaScript Archive File (.zip) file will be created in My Documents<ninjatrader folder="">\bin\Custom\ExportNinjaScript.The file can be imported by another NinjaTrader application on a different PC.Exporting NinjaScript as AssemblyNoteYou may want to provide other NinjaTrader users with access to your proprietary indicators or strategies in a secure format preventing them from being able to see your proprietary source code. You can do this by exporting your NinjaScript indicators as a compiled Microsoft .NET assembly (DLL) file.From the Control Center window select the menu Tools > Export > NinjaScript... to open the "Export NinjaScript" dialog window.Select the option "Export as compiled assembly".You can optionally select "Protect compiled assembly" (For information on protection see the "Protection/DLL Security" page).Press "add".Use the "Type" drop down to filter available NinjaScript types.Select all of the files that you want to export and press the "OK" button.A list of all files that will be exported will be shown.Optionally enter information that describes the assembly in the "Product" and "Version" fields.Press the "Export" button to export the selected files.A file dialog will open where you can choose the location your zip export file will be created in. Per default the NinjaScript Archive File (.zip) file will be created in My Documents<ninjatrader folder="">\bin\Custom\ExportNinjaScript.The file can be imported by another NinjaTrader application on a different PC.ON THIS PAGEExporting NinjaScript as Source FilesExporting NinjaScript as AssemblyExportYou can export NinjaScript for others to import in several formats:Source files - NinjaScript source files that can be imported and edited by others.Assemblies - A compiled assembly (DLL) of NinjaScript that "hides" your source code. This can be further protected by SecureTeam's Agile.NET to prevent theft of your intellectual property.Exporting NinjaScript as Source FilesYou may want to provide other NinjaTrader users with source files of your NinjaScript in a format where they are able to view and edit them.From the Control Center window select the menu Tools > Export > NinjaScript... to open the "Export NinjaScript" dialog window.Press "add".Use the "Type" drop down to filter available NinjaScript types.Select all of the files that you want to export and press the "OK" button.A list of all files that will be exported will be shown.Press the "Export" button to export the selected files.A file dialog will open where you can choose the location your zip export file will be created in. Per default the NinjaScript Archive File (.zip) file will be created in My Documents<ninjatrader folder="">\bin\Custom\ExportNinjaScript.The file can be imported by another NinjaTrader application on a different PC.Exporting NinjaScript as AssemblyNoteYou may want to provide other NinjaTrader users with access to your proprietary indicators or strategies in a secure format preventing them from being able to see your proprietary source code. You can do this by exporting your NinjaScript indicators as a compiled Microsoft .NET assembly (DLL) file.From the Control Center window select the menu Tools > Export > NinjaScript... to open the "Export NinjaScript" dialog window.Select the option "Export as compiled assembly".You can optionally select "Protect compiled assembly" (For information on protection see the "Protection/DLL Security" page).

[Content truncated...]


---

## 11. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/remove_ninjascript_assembly

**Captured:** 2025-07-07T18:16:13.351Z

### Page Structure

- Remove NinjaScript Assembly
  - Note
      - ON THIS PAGE
- Remove NinjaScript Assembly
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXRemove NinjaScript AssemblyThis will allow you to remove installed NinjaScript assembly files.To remove a NinjaScript assembly:From the Control Center window select the menu Tools > Remove NinjaScript Assembly.Select the file(s) you want to remove (MultiSelect would be possible via holding Shift pressed while selecting the desired files for removal).Press the Remove NinjaScript assembly button.NoteRemove NinjaScript Assembly will not unload existing assemblies until restart, this means you should not import the same assemblies again until you have restarted NinjaTrader.ON THIS PAGERemove NinjaScript AssemblyThis will allow you to remove installed NinjaScript assembly files.To remove a NinjaScript assembly:From the Control Center window select the menu Tools > Remove NinjaScript Assembly.Select the file(s) you want to remove (MultiSelect would be possible via holding Shift pressed while selecting the desired files for removal).Press the Remove NinjaScript assembly button.NoteRemove NinjaScript Assembly will not unload existing assemblies until restart, this means you should not import the same assemblies again until you have restarted NinjaTrader.ON THIS PAGE

---

## 12. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/export_problems

**Captured:** 2025-07-07T18:16:16.413Z

### Page Structure

- Export Problems
  - Note
  - Note
  - Note
      - ON THIS PAGE
- Export Problems
  - Note
  - Note
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXExport ProblemsIf you are having difficulties exporting NinjaScript it could be due to one of the following reasons:NoteIf you receive the above error, you will need to compile your NinjaScript error-free before you can export. To see if your NinjaScript file is error free, open the NinjaScript Editor (Tool > Edit NinjaScript) and press F5 to compile. If you are trying to check a NinjaScript Strategy created from the Strategy Wizard you can do the same by finishing the wizard and seeing if you receive the “Strategy successfully generated” message.If you receive any errors when compiling you will need to address them before exporting.If you are able to compile without errors and still experience exporting difficulties like the one above, check to see if you receive an error similar to this in the Control Center logs:"3/6/2014 9:25:30 AM|2|4|Error compiling export assembly: C:\Users\NinjaTrader\Documents\NinjaTrader 8\bin\Custom\Indicator\MyCustomIndicator.cs(42,18) : error CS0118: NinjaTrader.Indicator.SMA is a type but is used like a variable"NoteThis error may have a different error code and message depending on which variant of .NET you have installed. An error message indicative of this issue would include an indicator name without quotation marks.If you experience this error, please follow this procedure:Take note of which indicator is referenced by the error. In the above example, it is the SMAGo to your NinjaScript Export utility. (Tools > Export > NinjaScript...)After press "add" select “System indicators” from the "Type" drop downAdd the indicator that was referenced in the error to the export list along with your custom NinjaScript by pressing the > buttonPress the “Export” button to create your NinjaScript Archive File. If you receive the same error again, repeat this procedure until you add all the referenced system indicators and are able to successfully export your custom NinjaScript.NoteIf the indicator referenced in the error is another custom indicator you will need to follow the same procedure to add the custom indicator.ON THIS PAGEExport ProblemsIf you are having difficulties exporting NinjaScript it could be due to one of the following reasons:NoteIf you receive the above error, you will need to compile your NinjaScript error-free before you can export. To see if your NinjaScript file is error free, open the NinjaScript Editor (Tool > Edit NinjaScript) and press F5 to compile. If you are trying to check a NinjaScript Strategy created from the Strategy Wizard you can do the same by finishing the wizard and seeing if you receive the “Strategy successfully generated” message.If you receive any errors when compiling you will need to address them before exporting.If you are able to compile without errors and still experience exporting difficulties like the one above, check to see if you receive an error similar to this in the Control Center logs:"3/6/2014 9:25:30 AM|2|4|Error compiling export assembly: C:\Users\NinjaTrader\Documents\NinjaTrader 8\bin\Custom\Indicator\MyCustomIndicator.cs(42,18) : error CS0118: NinjaTrader.Indicator.SMA is a type but is used like a variable"NoteThis error may have a different error code and message depending on which variant of .NET you have installed. An error message indicative of this issue would include an indicator name without quotation marks.If you experience this error, please follow this procedure:Take note of which indicator is referenced by the error. In the above example, it is the SMAGo to your NinjaScript Export utility. (Tools > Export > NinjaScript...)After press "add" select “System indicators” from the "Type" drop downAdd the indicator that was referenced in the error to the export list along with your custom NinjaScript by pressing the > buttonPress the “Export” button to create your NinjaScript Archive File. If you receive the same error again, repeat this procedure until you add all the referenced system indicators and are able to successfully export your custom NinjaScript.NoteIf the indicator referenced in the error is another custom indicator you will need to follow the same procedure to add the custom indicator.ON THIS PAGE

---

## 13. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/protection_dll_security

**Captured:** 2025-07-07T18:16:19.358Z

### Page Structure

- Protection DLL Security
  - Protection/DLL Security
      - ON THIS PAGE
- Protection DLL Security
  - Protection/DLL Security
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXProtection DLL SecurityProtection/DLL SecurityAlthough .NET DLL files are compiled which prevents users from being able to see your proprietary source code, they are still subject to decompilation and reverse engineering attempts. If you want a higher level of security, you can select the "Protect compiled assemblies" option which adds an additional layer of protection. This additional protection layer is provided by SecureTeam's Agile.NET product which has been licensed by NinjaTrader and available at a reduced price to protect NinjaTrader assemblies. This product claims to completely stop MSIL disassembly and decompilation. We use it ourselves and are extremely happy with it.Should you wish to use Agile.NET for protecting your NinjaScript assemblies you will first need to go here to download and purchase the product. Once installed, please run the Agile.NET standalone product once to input in the license information you should have received when you downloaded it. After that, when you use NinjaTrader's Export NinjaScript utility and select the "Protect compiled assemblies" option for export, it will automatically protect your NinjaScript assembly with Agile.NET.Please note that this version of Agile.NET will only work for protecting NinjaScript assemblies within NinjaTrader. If you would like to protect other files outside of NinjaTrader please consider purchasing the full version of Agile.NET from SecureTeam directly here 'Agile.NET 6.0 Code Protection'. NinjaScript assemblies protected with the full version of Agile.NET will also work in NinjaTrader.At this time we recommend using version 6.9.1.2For clients on 8.0.28.0 or older you can continue to use 6.6.0.35ON THIS PAGEProtection/DLL SecurityProtection DLL SecurityProtection/DLL SecurityAlthough .NET DLL files are compiled which prevents users from being able to see your proprietary source code, they are still subject to decompilation and reverse engineering attempts. If you want a higher level of security, you can select the "Protect compiled assemblies" option which adds an additional layer of protection. This additional protection layer is provided by SecureTeam's Agile.NET product which has been licensed by NinjaTrader and available at a reduced price to protect NinjaTrader assemblies. This product claims to completely stop MSIL disassembly and decompilation. We use it ourselves and are extremely happy with it.Should you wish to use Agile.NET for protecting your NinjaScript assemblies you will first need to go here to download and purchase the product. Once installed, please run the Agile.NET standalone product once to input in the license information you should have received when you downloaded it. After that, when you use NinjaTrader's Export NinjaScript utility and select the "Protect compiled assemblies" option for export, it will automatically protect your NinjaScript assembly with Agile.NET.Please note that this version of Agile.NET will only work for protecting NinjaScript assemblies within NinjaTrader. If you would like to protect other files outside of NinjaTrader please consider purchasing the full version of Agile.NET from SecureTeam directly here 'Agile.NET 6.0 Code Protection'. NinjaScript assemblies protected with the full version of Agile.NET will also work in NinjaTrader.At this time we recommend using version 6.9.1.2For clients on 8.0.28.0 or older you can continue to use 6.6.0.35ON THIS PAGEProtection/DLL Security

---

## 14. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/ninjascript_editor_overview

**Captured:** 2025-07-07T18:16:23.354Z

### Page Structure

- NinjaScript Editor Overview
  - NinjaScript Editor Overview
  - Note
  - Display
  - Errors/Debugging
  - Coding Assistance
      - ON THIS PAGE
- NinjaScript Editor Overview
  - NinjaScript Editor Overview
  - Note
  - Display
  - Errors/Debugging
  - Coding Assistance
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionCommercial DistributionBest Practices for DistributionLicensing User AuthenticationDistribution ProcedureConsiderations for Compiled AssembliesImportExportRemove NinjaScript AssemblyExport ProblemsProtection DLL SecurityNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript Editor OverviewNinjaScript Editor OverviewThe NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators and strategies efficiently. The NinjaScript Editor includes powerful coding assistance and advanced debugging tools to help you custom build your indicator, strategy or any other supported NinjaScript type.NoteThe NinjaScript Editor provides advanced features for efficient scripting.DisplayEditor ComponentsNinjaScript ExplorerNinjaScript WizardErrors/DebuggingCompile ErrorsVisual Studio DebuggingCompile Error CodesCoding AssistanceIntellipromptCode SnippetsON THIS PAGENinjaScript Editor OverviewDisplayErrors/DebuggingCoding AssistanceNinjaScript Editor OverviewNinjaScript Editor OverviewThe NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators and strategies efficiently. The NinjaScript Editor includes powerful coding assistance and advanced debugging tools to help you custom build your indicator, strategy or any other supported NinjaScript type.NoteThe NinjaScript Editor provides advanced features for efficient scripting.DisplayEditor ComponentsNinjaScript ExplorerNinjaScript WizardErrors/DebuggingCompile ErrorsVisual Studio DebuggingCompile Error CodesCoding AssistanceIntellipromptCode SnippetsON THIS PAGENinjaScript Editor OverviewDisplayErrors/DebuggingCoding Assistance

---

## 15. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compile_error_codes

**Captured:** 2025-07-07T18:16:31.348Z

### Page Structure

- Compile Error Codes
      - ON THIS PAGE
- Compile Error Codes
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesCS0006CS0019CS0021CS0029CS0103CS0200CS0201CS0234CS0246CS0428CS0443CS1002CS1061CS1501CS1502CS1503CS1513CS1525No DocNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompile Error CodesThe following error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.CS0006CS0019CS0021CS0029CS0103CS0200CS0201CS0234CS0246CS0428CS0443CS1002CS1061CS1501CS1502CS1503CS1513CS1525NoDocON THIS PAGECompile Error CodesThe following error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.CS0006CS0019CS0021CS0029CS0103CS0200CS0201CS0234CS0246CS0428CS0443CS1002CS1061CS1501CS1502CS1503CS1513CS1525NoDocON THIS PAGE

---

## 16. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/ninjascript_editor_components

**Captured:** 2025-07-07T18:16:37.349Z

### Page Structure

- NinjaScript Editor Components
  - Overview
  - Context Menus
  - Properties and Definitions
      - ON THIS PAGE
- NinjaScript Editor Components
  - Overview
  - Context Menus
  - Properties and Definitions
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript Editor ComponentsOverviewThe NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators, strategies, and any other custom NinjaScript types used to enhance the NinjaTrader platform. The NinjaScript Editor can be opened by selecting the New menu from the NinjaTrader Control Center. Then left mouse click on the menu item NinjaScript Editor.NinjaScript Explorer - Displays files, folders, and allows for additional file managementTool bar - Moving your mouse over each icon will display the function of the icon buttonLine numbersLine modification marking - Yellow flags indicate unsaved line modifications where green flags indicate saved modificationsTabs for creating new scripts via the NinjaScript wizard and working on multiple scripts.Context MenusContext menus can be opened by right-clicking in the NinjaScript Editor.Context Menu ItemsSaveSaves pending changes to the currently open NinjaScriptSave AsCreates a copy of the script and attempts to rename the class name so the new script is uniqueInsert Code SnippetInserts a code snippet (see Code Snippets for more information)Go To Line...Moves the cursor to the line of code specified.UndoUndoes the last modificationRedoApplies the modification that was last UndoneCutRemoves selected text and copies to clipboardCopyCopies selected text to clipboardPastePastes the text saved in the clipboardRemoveRemoves the selected textSelect AllSelects all text in the Code EditorDebug ModeSets if a debug dll should be generated on compilation (see Visual Studio Debugging for more information)References...Opens the list of dll references used by NinjaTrader. This includes dll's used by NinjaTrader and dll's installed with custom Add On's.Show WarningsEnables Warning messages to be seen alongside compile errorsAlways On TopSets the NinjaScript Editor to viewed on top of other windowsPrintAllows printing the content of this window (see Printing Content for more information)ShareAllows sharing the content of this window (see Sharing Content for more information)PropertiesOpens the Properties menu (see below)Properties and DefinitionsGeneralAuto hide NinjaScript explorerSets if the NinjaScript explorer should be collapsed by defaultDebug modeSets if a debug dll should be generated on compilation (see Visual Studio Debugging for more information)Inline syntax checkingSets if errors and warnings should be detected as code is written (without needing to compile)Auto bracket completionSets if opening characters should automatically be appended closing characters. Works for (parentheses), [brackets], {braces}, <angled brackets>Show indentation linesDisplays vertical lines for code formattingShow WarningsSets if code warnings should be shown on compilation.FontSets the font optionsWindowAlways on topSets if the window will be always on top of other windows.ON THIS PAGEOverviewContext MenusProperties and DefinitionsNinjaScript Editor ComponentsOverviewThe NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators, strategies, and any other custom NinjaScript types used to enhance the NinjaTrader platform. The NinjaScript Editor can be opened by selecting the New menu from the NinjaTrader Control Center. Then left mouse click on the menu item NinjaScript Editor.NinjaScript Explorer - Displays files, folders, and allows for additional file managementTool bar - Moving your mouse over each icon will display the function of the icon buttonLine numbersLine modification marking - Yellow flags indicate unsaved line modifications where green flags indicate saved modificationsTabs for creating new scripts via the NinjaScript wizard and working on multiple scripts.Context MenusContext menus can be opened by right-clicking in the NinjaScript Editor.Context Menu ItemsSaveSaves pending changes to the currently open NinjaScriptSave AsCreates a copy of the script and attempts to rename the class name so the new script is uniqueInsert Code SnippetInserts a code snippet (see Code Snippets for more information)Go To Line...Moves the cursor to the line of code specified.UndoUndoes the last modificationRedoApplies the modification that was last UndoneCutRemoves selected text and copies to clipboardCopyCopies selected text to clipboardPastePastes the text saved in the clipboardRemoveRemoves the selected textSelect AllSelects all text in the Code EditorDebug ModeSets if a debug dll should be generated on compilation (see Visual Studio D

[Content truncated...]


---

## 17. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/ninjascript_explorer

**Captured:** 2025-07-07T18:16:40.350Z

### Page Structure

- NinjaScript Explorer
  - Understanding the NinjaScript Explorer display
    - Folder Displays
  - Pinning the NinjaScript Explorer
  - Right Click Menu
  - Managing scripts and folders
    - Opening an existing Script
    - Creating new scripts
    - Creating custom folders
  - Note
    - Renaming scripts and folders
  - Note
    - Removing scripts and folders
  - Note
    - Understanding Folders in the NinjaScript Editor and the File System
  - Warning
  - Excluding a script from compilation
    - Ignoring a script
  - Note
      - ON THIS PAGE
- NinjaScript Explorer
  - Understanding the NinjaScript Explorer display
    - Folder Displays
  - Pinning the NinjaScript Explorer
  - Right Click Menu
  - Managing scripts and folders
    - Opening an existing Script
    - Creating new scripts
    - Creating custom folders
  - Note
    - Renaming scripts and folders
  - Note
    - Removing scripts and folders
  - Note
    - Understanding Folders in the NinjaScript Editor and the File System
  - Warning
  - Excluding a script from compilation
    - Ignoring a script
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript ExplorerThe NinjaScript Explorer provides a Folder view of all the supported NinjaScript categories that can be developed in NinjaTrader.Understanding the NinjaScript Explorer displayFolder DisplaysThe NinjaScript Explorer will organize each script installed on your system by type of NinjaScript object (Indicator, Strategy, SuperDOM Column, etc). Each folder will display the following scripts under each section:Locked scriptsPre-built system scripts which come installed with NinjaTrader which can be viewed as read-only and are required for compilation (of course you can safe a custom copy of those to modify)Custom scriptsAny script imported, or under development, which can be modifiedIgnored custom scriptsCustom scripts which have been excluded from compilation (see the "Excluding a script from compilation" section below for more information)Pinning the NinjaScript ExplorerBy default the NinjaScript Explorer will be "pinned" to the right side of the NinjaScript editor, however it can be collapsed out of view by pressing the pin icon NS_Editor_14 located at the top right of the explorer window.Once the NinjaScript Explorer is collapsed, you can quickly bring it back in view simply by selecting the NinjaTrader Explorer tab located on the right side. Selecting the pin icon NS_Editor_15 again will re-pin the NinjaScript Explorer to the NinjaScript Editor.Right Click MenuRight clicking on an individual folder or script will give you a number of different menu items to help with the management of your custom scripts.NewOpens the NinjaScript Wizard for the relevant object type.OpenOpens the selected script in a new tab in the current NinjaScript Editor windowOpen In New NinjaScript EditorOpens the selected script(s) in a new NinjaScript Editor windowExclude From CompilationPrevents the selected script(s) from being compiled (see the "Excluding a script from compilation" section below for more information)RemoveRemoves the current file or folder from the systemNew FolderCreates a new custom folder to organize your scriptsRenameRenames the current selected file or folderManaging scripts and foldersOpening an existing ScriptThere are two ways to open a script:Double left mouse click on the script you wish to view or edit in the current windowRight mouse click on the script and select open to view or edit the script as a tab the current window, or select Open in NinjaScript Editor to open the script as a tab in a new windowCreating new scriptsRight clicking on a NinjaScript category and selecting New... will open the NinjaScript wizard allowing you to create new custom scripts.Please see the Help Topic on the NinjaScript Wizard for more information.Creating custom foldersThe NinjaScript Explorer gives you the flexibility to relocate and organize your custom scripts in a number of custom user defined folders.To create a new folder, simply right click on the NinjaScript folder category you wish to organize, select New Folder, and use your keyboard to type a user defined name to identify the folder.Once you have created your new folder, using your mouse you can drag and drop any custom scripts of its category under this folder.NoteNotes:You cannot relocate a locked system script.You can only relocate a custom script if it is closed from the NinjaScript Editor.You can only relocate a script to a folder under its own folder category (i.e., custom strategies can only be placed under the strategy folder, it would not be possible to move it to an indicator folder).If you move a child script that is called by a parent, please be sure to update the references to the child as well, as the new folder you assigned will automatically move the child to a new namespace.Renaming scripts and foldersThere are two methods for renaming custom scripts:Right mouse click on the script from the NinjaScript explorer and select Rename.Select the desired script and press the F2 key on your keyboard.Renaming a script will automatically rename all relevant class names and all other required components.NoteNotes:You cannot rename a locked system script or folder.You can only rename a custom script when it is closed.You can only rename a folder if all of the scripts contained are closed.Removing scripts and foldersThere are two methods for removing custom scripts from your system:Right mouse click on the script from the NinjaScript explorer and select Remove.Select the desired script and press the DEL key on your keyboard.Removing a script w

[Content truncated...]


---

## 18. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/ninjascript_wizard

**Captured:** 2025-07-07T18:16:43.350Z

### Page Structure

- NinjaScript Wizard
  - Opening the NinjaScript Wizard
    - Creating a new NinjaScript file
  - Understand the NinjaScript Wizard Display
    - Display Overview
  - Understanding the Wizard Screens
    - Optional Pages
      - ON THIS PAGE
- NinjaScript Wizard
  - Opening the NinjaScript Wizard
    - Creating a new NinjaScript file
  - Understand the NinjaScript Wizard Display
    - Display Overview
  - Understanding the Wizard Screens
    - Optional Pages
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript WizardThe NinjaScript Wizard is used to generate the minimum code to get started programming any supported NinjaScript type. This wizard will allow you to define any default properties, add custom input parameters, add additional data series, and add any relevant event methods. There are a number of different properties and options available in the NinjaScript Wizard depending on the type of NinjaScript object you are creating.The information on this page is to be used as a standard overview of the various components of the NinjaScript Wizard. For more information on NinjaScript methods and properties, please see the NinjaScript Language Reference section of our Help Guide.Opening the NinjaScript WizardCreating a new NinjaScript fileThe NinjaScript Wizard can be opened from the NinjaScript Editor by selecting the + symbol on the tab row, and then selecting the NinjaScript object type you wish to develop.You can also right click on any of the NinjaScript categories listed in the NinjaScript Explorer and select "New..."Understand the NinjaScript Wizard DisplayDisplay OverviewWizard Navigation MenuUsed to navigate to various pages of the wizard.  You can skip ahead or return to any page in the wizard at any time.Wizard ScreenDisplays relevant information pertaining to the step of wizard you have navigated to and will provide instructions to help you define your script at various stages.Wizard ControlsButtons used to perform various actions pertaining to the script that is being created.  Selecting Generate at any time will exit the wizard and open your script in the NinjaScript Code Editor (Note:  You cannot return back to the NinjaScript Wizard once the code is generated).Understanding the Wizard ScreensOptional PagesThe NinjaScript Wizard has a number of different pages available used to define various steps of your custom script. Please note that the table below describes ALL of the pages available from the Wizard, but does not imply that these steps will be available for the script you are currently creating.WelcomeThe first step of the Wizard, used to identify which type of object is being createdGeneralUsed to define a name and description to identify the NinjaScript fileDefault PropertiesSets various properties and start behavior for the script being createdAdditional DataUsed to optionally add additional data series such as minute, tick, etc or even custom series you may plan on calculating programmaticallyAdditional Event MethodsOptionally add additional event methods to your custom script, such as OnMarketData, OnMarketDepth, etcInput ParametersUsed to define any public properties that may be used in your scriptPlots and LinesOptionally add visual plots or lines to your script for charting purposesFinishLast page of the Wizard, gives you a chance to go back and review each page if desired before finishing generating the script.ON THIS PAGEOpening the NinjaScript WizardUnderstand the NinjaScript Wizard DisplayUnderstanding the Wizard ScreensNinjaScript WizardThe NinjaScript Wizard is used to generate the minimum code to get started programming any supported NinjaScript type. This wizard will allow you to define any default properties, add custom input parameters, add additional data series, and add any relevant event methods. There are a number of different properties and options available in the NinjaScript Wizard depending on the type of NinjaScript object you are creating.The information on this page is to be used as a standard overview of the various components of the NinjaScript Wizard. For more information on NinjaScript methods and properties, please see the NinjaScript Language Reference section of our Help Guide.Opening the NinjaScript WizardCreating a new NinjaScript fileThe NinjaScript Wizard can be opened from the NinjaScript Editor by selecting the + symbol on the tab row, and then selecting the NinjaScript object type you wish to develop.You can also right click on any of the NinjaScript categories listed in the NinjaScript Explorer and select "New..."Understand the NinjaScript Wizard DisplayDisplay OverviewWizard Navigation MenuUsed to navigate to various pages of the wizard.  You can skip ahead or return to any page in the wizard at any time.Wizard ScreenDisplays relevant information pertaining to the step of wizard you have navigated to and will provide instructions to help you define your script at various stages.Wizard ControlsButtons used to perform various actions pertaini

[Content truncated...]


---

## 19. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/code_snippets

**Captured:** 2025-07-07T18:16:47.352Z

### Page Structure

- Code Snippets
  - Code Snippets
  - Understanding Code Snippet shortcuts
  - How to insert Code Snippets via the mouse or F2 key
    - Using the keyboard
    - Previous Bar Values
      - ON THIS PAGE
- Code Snippets
  - Code Snippets
  - Understanding Code Snippet shortcuts
  - How to insert Code Snippets via the mouse or F2 key
    - Using the keyboard
    - Previous Bar Values
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCode SnippetsCode SnippetsCode Snippets can provide you with useful code templates to speed up your coding process.Understanding Code Snippet shortcutsShortcutMethod SignaturedapDraw.AndrewsPitchfork(this, "MyAndrewsPitchfork", false, 10, Close[10], 5, High[5], 0, Low[5], Brushes.Blue, DashStyleHelper.Solid, 1);daDraw.Arc(this, "MyDrawArc", false, 10, Close[10], 0, Close[0], Brushes.LimeGreen, DashStyleHelper.Dot, 2);ddDraw.ArrowDown(this, "MyArrowDown", false, 0, High[0], Brushes.Red);duDraw.ArrowUp(this, "MyArrowUp", false, 0, Low[0], Brushes.Red);ddiDraw.Diamond(this, "MyDiamond", false, 0, High[0] + 2 * TickSize, Brushes.Blue);dtDraw.Dot(this, "MyDot", false, 0, High[0] + 2 * TickSize, Brushes.Blue);deDraw.Ellipse(this, "MyEllipse", 10, Low[10], 0, High[0], Brushes.Blue);diDraw.ExtendedLine(this, "MyExtendedLine", 10, Close[10], 0, Close[0], Brushes.Blue);dfcDraw.FibonacciCircle(this, "MyFibonacciCircle", true, 10, Close[10], 0, Close[0]);dfeDraw.FibonacciExtensions(this, "MyFibonacciExtensions", true, 15, Close[15], 10, Close[10], 5, Close[5]);dfrDraw.FibonacciRetracements(this, "MyFibonacciRetracements", false, 10, Close[10], 0, Close[0]);dftDraw.FibonacciTimeExtensions(this, "MyFibonacciTimeExtensions", false, 10, Close[10], 0, Close[0]);dgDraw.GannFan(this, "MyGannFan", true, 10, Close[10]);dhDraw.HorizontalLine(this, "MyHorizontalLine", Close[0], Brushes.Blue);dlDraw.Line(this, "MyLine", 10, Close[10], 0, Close[0], Brushes.Blue);dyDraw.Ray(this, "MyRay", 10, Close[10], 0, Close[0], Brushes.Blue);drDraw.Rectangle(this, "MyRectangle", 10, Low[10], 0, High[0], Brushes.Blue);dreDraw.Region(this, CurrentBar, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, Brushes.Green, Brushes.Blue, 50);drxDraw.RegionHighlightX(this, "MyRegionHighlightX", 10, 0, Brushes.Blue);dryDraw.RegionHighlightY(this, "MyRegionHighlightY", High[0], Low[0], Brushes.Blue, Brushes.Green, 20);drrDraw.RiskReward(this, "MyRiskReward", false, 0, High[0], 10, Low[0], 2, true);druDraw.Ruler(this, "tag1", true, 4, Low[4], 3, High[3], 1, Low[1]);dsDraw.Square(this, "MySquare", false, 0, High[0] + 2 * TickSize, Brushes.Blue);dxDraw.Text(this, "MyText", "Sample text ", 0, High[0] + 2 * TickSize, Brushes.Blue);dxfDraw.TextFixed(this, "MyTextFixed", "Text to draw", TextPosition.TopRight);dtcDraw.TrendChannel(this, "TrendChannel", true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);dtdDraw.TriangleDown(this, "MyTriangleDown", false, 0, High[0] + 2 * TickSize, Brushes.Red);dtuDraw.TriangleUp(this, "MyTriangleUp", false, 0, Low[0] - 2 * TickSize, Brushes.Blue);dvDraw.VerticalLine(this, "MyVerticalLine", 0, Brushes.Blue);How to insert Code Snippets via the mouse or F2 keyUsing the keyboardEnter the text in the left column and press the "Tab" key within the NinjaScript Editor.cbCurrentBaroOpen[0]hHigh[0]lLow[0]vVolume[0]iInput[0]Previous Bar Valuesc1Close[1]o1Open[1]h1High[1]l1Low[1]v1Volume[1]i1Input[1]Right mouse click in the NinjaScript Editor and select the menu name "Insert Code Snippet"A menu will display all available code snippets.ON THIS PAGECode SnippetsUnderstanding Code Snippet shortcutsHow to insert Code Snippets via the mouse or F2 keyCode SnippetsCode SnippetsCode Snippets can provide you with useful code templates to speed up your coding process.Understanding Code Snippet shortcutsShortcutMethod SignaturedapDraw.AndrewsPitchfork(this, "MyAndrewsPitchfork", false, 10, Close[10], 5, High[5], 0, Low[5], Brushes.Blue, DashStyleHelper.Solid, 1);daDraw.Arc(this, "MyDrawArc", false, 10, Close[10], 0, Close[0], Brushes.LimeGreen, DashStyleHelper.Dot, 2);ddDraw.ArrowDown(this, "MyArrowDown", false, 0, High[0], Brushes.Red);duDraw.ArrowUp(this, "MyArrowUp", false, 0, Low[0], Brushes.Red);ddiDraw.Diamond(this, "MyDiamond", false, 0, High[0] + 2 * TickSize, Brushes.Blue);dtDraw.Dot(this, "MyDot", false, 0, High[0] + 2 * TickSize, Brushes.Blue);deDraw.Ellipse(this, "MyEllipse", 10, Low[10], 0, High[0], Brushes.Blue);diDraw.ExtendedLine(this, "MyExtendedLine", 10, Close[10], 0, Close[0], Brushes.Blue);dfcDraw.FibonacciCircle(this, "MyFibonacciCircle", true, 10, Close[10], 0, Close[0]);dfeDraw.FibonacciExtensions(this, "MyFibonacciExtensions", true, 15, Close[15], 10, Close[10], 5, Close[5]);dfrDraw.FibonacciRetracements(this, "MyFibonacciRetracements", false, 10, Close[10], 0, Close[0]);dftDraw.FibonacciTimeExtensions(this, "MyFibonacciTimeExtensions", false, 10, Close[10], 0, Close[0]);dgDraw.GannFan(this, "MyGannFan", true, 10, Close[10]);

[Content truncated...]


### Code Examples

#### Example 1

```csharp
Draw.AndrewsPitchfork(this, "MyAndrewsPitchfork", false, 10, Close[10], 5, High[5], 0, Low[5], Brushes.Blue, DashStyleHelper.Solid, 1);
```

#### Example 2

```csharp
Draw.Arc(this, "MyDrawArc", false, 10, Close[10], 0, Close[0], Brushes.LimeGreen, DashStyleHelper.Dot, 2);
```

#### Example 3

```csharp
Draw.ArrowDown(this, "MyArrowDown", false, 0, High[0], Brushes.Red);
```

---

## 20. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compile_errors

**Captured:** 2025-07-07T18:16:50.352Z

### Page Structure

- Compile Errors
  - When compiling a custom indicator or strategy it is possible and likely that you will generate compile errors
  - The image below illustrates a compile error
      - ON THIS PAGE
- Compile Errors
  - When compiling a custom indicator or strategy it is possible and likely that you will generate compile errors
  - The image below illustrates a compile error
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompile ErrorsWhen compiling a custom indicator or strategy it is possible and likely that you will generate compile errorsNinjaTrader will compile ALL NinjaScript files NOT only the file you are working on.A list of compile errors for all files will be displayed in the lower portion of the NinjaScript Editor.Double click on an error to load the problem file and highlight the problem area.Click on the error code to bring up Help Documentation on a specific error.Right click on the error to exclude the problem file from compilation (see the section on Excluding a script from compilation for more information).The image below illustrates a compile errorSection where compile errors are displayed. Errors in the current loaded file are color coded a light color while errors in other files have a darker color code.The file that contains the error.A description of the error.A error code link that will open the Help Guide with any relevant error code information.Line number and column number of the error.Error is underlined with a red wavy line.The error highlighted by icon (6) below shows that the expression is not closed with a semicolon. The expression should be:double myValue = SMA(20)[0];
ON THIS PAGEWhen compiling a custom indicator or strategy it is possible and likely that you will generate compile errorsThe image below illustrates a compile errorCompile ErrorsWhen compiling a custom indicator or strategy it is possible and likely that you will generate compile errorsNinjaTrader will compile ALL NinjaScript files NOT only the file you are working on.A list of compile errors for all files will be displayed in the lower portion of the NinjaScript Editor.Double click on an error to load the problem file and highlight the problem area.Click on the error code to bring up Help Documentation on a specific error.Right click on the error to exclude the problem file from compilation (see the section on Excluding a script from compilation for more information).The image below illustrates a compile errorSection where compile errors are displayed. Errors in the current loaded file are color coded a light color while errors in other files have a darker color code.The file that contains the error.A description of the error.A error code link that will open the Help Guide with any relevant error code information.Line number and column number of the error.Error is underlined with a red wavy line.The error highlighted by icon (6) below shows that the expression is not closed with a semicolon. The expression should be:double myValue = SMA(20)[0];
ON THIS PAGEWhen compiling a custom indicator or strategy it is possible and likely that you will generate compile errorsThe image below illustrates a compile error

### Code Examples

#### Example 1

```csharp
double myValue = SMA(20)[0];
```

#### Example 2

```csharp
double myValue = SMA(20)[0];
```

#### Example 3

```csharp
double myValue = SMA(20)[0];
```

---

## 21. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/intelliprompt

**Captured:** 2025-07-07T18:16:53.354Z

### Page Structure

- Intelliprompt
  - What is Intelliprompt?
  - How to access the Intelliprompt list box
  - Understanding Method Description and Signatures
    - What is a method signature?
      - ON THIS PAGE
- Intelliprompt
  - What is Intelliprompt?
  - How to access the Intelliprompt list box
  - Understanding Method Description and Signatures
    - What is a method signature?
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXIntellipromptWhat is Intelliprompt?Intelliprompt is a form of automated autocompletion popularized by the Microsoft Visual Studio Integrated Development Environment. It also serves as documentation and disambiguation for variable names, functions and methods. Intelliprompt is built into the NinjaScript Editor resulting in an efficient environment to code your custom indicators and strategies.How to access the Intelliprompt list boxWithin the NinjaScript Editor you can type "this." to bring up the Intelliprompt list box. The list box contains all methods (functions) and properties available for use. You can select a method or property by simply selecting it via your mouse, or scrolling with your up or down arrow key. Pressing either the Tab or Enter key will automatically insert the code into the NinjaScript Editor. While in the list box, you can press any letter key to rapidly scroll down to the next property or method beginning with the letter of the key you pressed.In the image below:A propertyA methodIf you know that you want to access the Simple Moving Average indicator method which is SMA(), and you think it starts with "SM" enter "SM" and press CTRL-Space Bar which would display the Intelliprompt list box below.Pressing CTRL + space bar after any text will always eitherBring up the Intelliprompt list box with related methods and propertiesAutomatically insert code if the text can uniquely identify a method or propertyMore keyboard shortcuts could be reviewed under this linkUnderstanding Method Description and SignaturesWhen selecting a methodType in "(" to display the method description and signatureA light yellow colored frame will appear with the method description and available signaturesIn the image below you will see "1 of 3" which means that we are looking at the first of three available method signatures. You can scroll through all available signatures by pressing on the arrow up and down keys.What is a method signature?A method signature is a common term used in object-oriented programming to uniquely identify a method. This usually includes the method name, the number and type of its parameters and its return type.From the image above, the DMI() method represents the Dynamic Momentum Index indicator has two method signatures:DMI(int period)DMI(IDataSeries inputData, int period)ON THIS PAGEWhat is IntellipromptHow to access the Intelliprompt list boxUnderstanding Method Description and SignaturesIntellipromptWhat is Intelliprompt?Intelliprompt is a form of automated autocompletion popularized by the Microsoft Visual Studio Integrated Development Environment. It also serves as documentation and disambiguation for variable names, functions and methods. Intelliprompt is built into the NinjaScript Editor resulting in an efficient environment to code your custom indicators and strategies.How to access the Intelliprompt list boxWithin the NinjaScript Editor you can type "this." to bring up the Intelliprompt list box. The list box contains all methods (functions) and properties available for use. You can select a method or property by simply selecting it via your mouse, or scrolling with your up or down arrow key. Pressing either the Tab or Enter key will automatically insert the code into the NinjaScript Editor. While in the list box, you can press any letter key to rapidly scroll down to the next property or method beginning with the letter of the key you pressed.In the image below:A propertyA methodIf you know that you want to access the Simple Moving Average indicator method which is SMA(), and you think it starts with "SM" enter "SM" and press CTRL-Space Bar which would display the Intelliprompt list box below.Pressing CTRL + space bar after any text will always eitherBring up the Intelliprompt list box with related methods and propertiesAutomatically insert code if the text can uniquely identify a method or propertyMore keyboard shortcuts could be reviewed under this linkUnderstanding Method Description and SignaturesWhen selecting a methodType in "(" to display the method description and signatureA light yellow colored frame will appear with the method description and available signaturesIn the image below you will see "1 of 3" which means that we are looking at the first of three available method signatures. You can scroll through all available signatures by pressing on the arrow up and down keys.What is a method signature?A method signature is a common term used in object-oriented programming to

[Content truncated...]


### Code Examples

#### Example 1

```csharp
DMI(int period)
```

#### Example 2

```csharp
DMI(IDataSeries inputData, int period)
```

#### Example 3

```csharp
DMI(int period)
```

---

## 22. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/output_window

**Captured:** 2025-07-07T18:17:00.360Z

### Page Structure

- Output Window
  - Understanding the Output window display
    - Display Overview
    - Right click menu
  - Understanding the dual tab view
    - Dual view
    - Synchronized Scrolling
  - Searching and highlighting
    - Using the Find Tool
  - Clearing and saving output information
    - Clearing Output Information
    - Saving Output Information
  - Output window properties
  - NinjaScript Utilization Monitor
      - ON THIS PAGE
- Output Window
  - Understanding the Output window display
    - Display Overview
    - Right click menu
  - Understanding the dual tab view
    - Dual view
    - Synchronized Scrolling
  - Searching and highlighting
    - Using the Find Tool
  - Clearing and saving output information
    - Clearing Output Information
    - Saving Output Information
  - Output window properties
  - NinjaScript Utilization Monitor
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXOutput WindowThe NinjaScript Output is a powerful debugging tool which can be used to further analyze valuable information generated by your NinjaScript files. The Output window will only display data when other debugging methods such as the Print() or TraceOrders (for strategies) have been configured in a custom script.You can open the NinjaScript Output window by going to the New menu, and selecting NinjaScript Output.Understanding the Output window displayDisplay OverviewOutput tableThe main component of the Output window, will display any Print or Information message sent from a scriptScrollbarUsed to navigate up/down on the output windowOutput tabsTwo tabs available allowing you to separate the Print information for separate scripts.Line highlightLeft clicking on a line will highlight a particular point of interest and will remain highlighted as the Output window updates or is scrolled up and downRight click menuClearClears the current content of the select Output window tabFind...Searches for a term in the Output windowSave As...Saves the current content of the Output window in a text fileAlways On TopSets the window to always be on top of other windowsDual ViewEnables/Disables the splitting of the Output tabs between the window allowing you to view both tabs at simultaneouslySynchronize Vertical ScrollingWhen enabled, both tabs will scroll up/down at the same time and paceNinjaScript Utilization MonitorOpens the NinjaScript Utilization Monitor windowPrintDisplays options for printing the current window content to your printerShareDisplays the Share optionsPropertiesSets the Output window propertiesUnderstanding the dual tab viewDual viewYou can optionally split the Output window tab's into a dual view which will allow you to view both outputs windows at the same time. To enable this feature, simply right click on the Output window and select Dual view.In the image above, we have enabled the dual view mode where we can see the output from two separate indicators. MyCustomIndicator is programmed to print to the Output 1 tab, while MyCustomIndicator1 is programmed to print to the Output 2 tab. (Please see the Help Guide article on the PrintTo() method for more information on programming a custom script to print to a second output tab).Synchronized ScrollingWhile the Output window is in Dual view mode, each output window will have an independent scroll bar which allows you to navigate each output tab separately. However if desired, you can synchronize the vertical scrolling between these two windows which will allow you to easily compare the output from two different scripts where both tabs will scroll up/down equally at the same time.To enable this feature, right click on the Output window and select the Synchronized Vertical Scrolling menu item.Searching and highlightingUsing the Find ToolIf you would like to search for a specific value or text displayed in your Output window, you can use the Find tool to both highlight and navigate any terms that match your search.To bring up the Find menu, right click on the Output window and select Find (or use CTRL + F as a keyboard shortcut).To search for a specific term:Enter the text/value you wish to search forSpecify which Output tab you would like to searchOptionally check Match case to only look for terms which contain the exact text case of your term (i.e., Close would not be the same as close)Select the Find button which will navigate to and highlight the next matching term (indicated by the green arrow in the image below)The search will also highlight any other matches in the output window that match the searchSelecting the Find button again will continue to search through the Output window and will highlight the next match.Tip: With the Find tool, you can also highlight terms simply by double clicking on the text in the output window. Doing so will automatically search the highlighted term and highlight all results.Clearing and saving output informationClearing Output InformationAfter some time, you may feel the need to erase all the current information in the current output tab. To do so, simply right click on the current output tab and select "Clear".Tip: You can also use the ClearOutputWindow() method in directly your script to automatically clear the output content at a specific event or interval.Saving Output InformationIf you would like to save the current results of your output, you can right mouse click on the desired output tab and select "Save As".

[Content truncated...]


---

## 23. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/visual_studio_debugging

**Captured:** 2025-07-07T18:17:04.348Z

### Page Structure

- Visual Studio Debugging
  - Note
  - Using Visual Studio Debugging
  - Note
      - ON THIS PAGE
- Visual Studio Debugging
  - Note
  - Using Visual Studio Debugging
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXVisual Studio DebuggingYou can debug your NinjaScript objects using Microsoft Visual Studio. NinjaScript objects are compiled into a single DLL, named "NinjaTrader.Custom.dll." When debugging, a special debug DLL is created for temporary use, with the same name as the release version.NoteNotes:Using the debug DLL can incur a runtime performance impact, so it is recommended to disable Visual Studio debugging and re-compile your scripts when finished. This will replace the debug DLL with the release version.The Visual Studio button will work with Visual Studio 2019 or 2022 - if multiple versions are installed, it will start the highest one.Using Visual Studio DebuggingIn the NinjaScript Editor, enable "Debug Mode" via the right-click menu, as seen in the image below. After this, compile your scripts to create the debug DLL.From the NinjaScript Editor, click on the Visual Studio icon  from the tool bar, which will automatically load the NinjaTrader.Custom project with your installed version of Visual Studio.In Visual Studio, select Debug, then select Attach to ProcessSelect NinjaTrader from the list of processes, then select Attach. Be sure the "Attach to" field is set to "Automatic: Managed code" or "Managed code".Open the NinjaScript source file within Microsoft Visual Studio and set your break point(s)Run your NinjaScript object in NinjaTrader and it should stop at your break points and all the debugging tools and information should be available to inspect the current state of the code.NoteYou can also use Visual Studio as editor for your NinjaScript files - for that open the project as in step 2 above and then use Visual Studio for editing and once done save the file (don't run or build the solution then in Visual Studio), preferably with the NinjaScript editor opened still at the same time, so changes would be auto compiled in then.ON THIS PAGEUsing Visual Studio DebuggingVisual Studio DebuggingYou can debug your NinjaScript objects using Microsoft Visual Studio. NinjaScript objects are compiled into a single DLL, named "NinjaTrader.Custom.dll." When debugging, a special debug DLL is created for temporary use, with the same name as the release version.NoteNotes:Using the debug DLL can incur a runtime performance impact, so it is recommended to disable Visual Studio debugging and re-compile your scripts when finished. This will replace the debug DLL with the release version.The Visual Studio button will work with Visual Studio 2019 or 2022 - if multiple versions are installed, it will start the highest one.Using Visual Studio DebuggingIn the NinjaScript Editor, enable "Debug Mode" via the right-click menu, as seen in the image below. After this, compile your scripts to create the debug DLL.From the NinjaScript Editor, click on the Visual Studio icon  from the tool bar, which will automatically load the NinjaTrader.Custom project with your installed version of Visual Studio.In Visual Studio, select Debug, then select Attach to ProcessSelect NinjaTrader from the list of processes, then select Attach. Be sure the "Attach to" field is set to "Automatic: Managed code" or "Managed code".Open the NinjaScript source file within Microsoft Visual Studio and set your break point(s)Run your NinjaScript object in NinjaTrader and it should stop at your break points and all the debugging tools and information should be available to inspect the current state of the code.NoteYou can also use Visual Studio as editor for your NinjaScript files - for that open the project as in step 2 above and then use Visual Studio for editing and once done save the file (don't run or build the solution then in Visual Studio), preferably with the NinjaScript editor opened still at the same time, so changes would be auto compiled in then.ON THIS PAGEUsing Visual Studio Debugging

---

## 24. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/editor_keyboard_shortcuts

**Captured:** 2025-07-07T18:17:07.347Z

### Page Structure

- Editor Keyboard Shortcuts
      - ON THIS PAGE
- Editor Keyboard Shortcuts
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewCompile Error CodesNinjaScript Editor ComponentsNinjaScript ExplorerNinjaScript WizardCode SnippetsCompile ErrorsIntellipromptOutput WindowVisual Studio DebuggingEditor Keyboard ShortcutsEducational ResourcesUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEditor Keyboard ShortcutsThe NinjaScript Editor includes a range of keyboard shortcuts not available in other areas of the platform. Below is a list of available shortcuts and the actions they perform:ShortcutActionCtrl + C, Ctrl +InsertCopy to ClipboardCtrl + X, Shift + DeleteCut to ClipboardCtrl + LCut line to ClipboardCtrl + V, Shift + InsertPaste from ClipboardCtrl + Y, Ctrl + Shift + ZRedo actionCtrl + ZUndo actionCtrl + BackspaceBackspace to previous wordCtrl + Shift + LDelete lineCtrl + DeleteDelete to next wordCtrl + EnterOpen line aboveCtrl + Shift + EnterOpen line belowCtrl + SpaceIntelliprompt auto-completeCtrl + Shift + SpaceIntelliprompt show parametersCtrl + TTranspose charactersCtrl + Shift + TTranspose wordsShift + Alt + TTranspose linesCtrl + Shift + UMake uppercaseShift + TabRemove tab indentAlt + UpMove selected lines upAlt + DownMove selected lines downCtrl + LeftMove to previous wordCtrl + RightMove to next wordCtrl + HomeMove to document startCtrl + EndMove to document endCtrl + PageUpMove to visible top of documentCtrl + PageDownMove to visible bottom of documentCtrl + ]Move to matching bracketCtrl + DownScroll downCtrl + UpScroll upShift + PageUpSelect all aboveShift + PageDownSelect all belowCtrl + Shift + PageUpSelect visible area aboveCtrl + Shift + PageDownSelect visible area belowCtrl + Shift + WSelect wordCtrl + Shift + ]Select up to matching bracketShift + Alt + Arrow KeysExpand/contract selection regionON THIS PAGEEditor Keyboard ShortcutsThe NinjaScript Editor includes a range of keyboard shortcuts not available in other areas of the platform. Below is a list of available shortcuts and the actions they perform:ShortcutActionCtrl + C, Ctrl +InsertCopy to ClipboardCtrl + X, Shift + DeleteCut to ClipboardCtrl + LCut line to ClipboardCtrl + V, Shift + InsertPaste from ClipboardCtrl + Y, Ctrl + Shift + ZRedo actionCtrl + ZUndo actionCtrl + BackspaceBackspace to previous wordCtrl + Shift + LDelete lineCtrl + DeleteDelete to next wordCtrl + EnterOpen line aboveCtrl + Shift + EnterOpen line belowCtrl + SpaceIntelliprompt auto-completeCtrl + Shift + SpaceIntelliprompt show parametersCtrl + TTranspose charactersCtrl + Shift + TTranspose wordsShift + Alt + TTranspose linesCtrl + Shift + UMake uppercaseShift + TabRemove tab indentAlt + UpMove selected lines upAlt + DownMove selected lines downCtrl + LeftMove to previous wordCtrl + RightMove to next wordCtrl + HomeMove to document startCtrl + EndMove to document endCtrl + PageUpMove to visible top of documentCtrl + PageDownMove to visible bottom of documentCtrl + ]Move to matching bracketCtrl + DownScroll downCtrl + UpScroll upShift + PageUpSelect all aboveShift + PageDownSelect all belowCtrl + Shift + PageUpSelect visible area aboveCtrl + Shift + PageDownSelect visible area belowCtrl + Shift + WSelect wordCtrl + Shift + ]Select up to matching bracketShift + Alt + Arrow KeysExpand/contract selection regionON THIS PAGE

---

## 25. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/creating_your_own_addon_window

**Captured:** 2025-07-07T18:17:14.345Z

### Page Structure

- Creating Your Own AddOn Window
  - The NTWindow Class
  - Using TabControl for Tab Functionality
  - Note
  - Creating an NTTabPage within an NTWindow
  - Setting Up Workspace Persistence
  - Using XAML to Define Window Layout
  - Using C# to Define Window Layout
  - Launching Your Window From the Control Center
  - Adding NinjaTrader Custom Controls
    - 1. The Instrument Selector
    - 2. The Interval Selector
    - 3. The Quantity Up/Down Selector
    - 4. The Time-in-Force Selector
    - 5. The ATM Strategy Selector
      - Using the ATM Strategy Selector
  - Linking with Other Windows
      - ON THIS PAGE
- Creating Your Own AddOn Window
  - The NTWindow Class
  - Using TabControl for Tab Functionality
  - Note
  - Creating an NTTabPage within an NTWindow
  - Setting Up Workspace Persistence
  - Using XAML to Define Window Layout
  - Using C# to Define Window Layout
  - Launching Your Window From the Control Center
  - Adding NinjaTrader Custom Controls
    - 1. The Instrument Selector
    - 2. The Interval Selector
    - 3. The Quantity Up/Down Selector
    - 4. The Time-in-Force Selector
    - 5. The ATM Strategy Selector
      - Using the ATM Strategy Selector
  - Linking with Other Windows
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewCreating Your Own AddOn WindowDeveloping Add OnsOther Uses for an AddOnC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCreating Your Own AddOn WindowThe NTWindow ClassThe NTWindow class allows you to quickly build windows using the same style and skin as other windows in NinjaTrader. An NTWindow does not contain user-interface functionality, but rather serves as a container for instances of NTTabPage, which will contain controls and functionality for the window./* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
} 
Using TabControl for Tab FunctionalityAfter declaring an NTWindow, you can enable tab functionality on it (creating new tabs, copying tabs, etc.). The process for implementing tab functionality must be done within the constructor for your NTWindow, using the following process:Instantiate a new TabControl objectCall helper methods of the TabControlManager class, passing in your TabControl object as an argument, to enable specific functionalityUse the same approach as #2 to set an NTTabFactory for your TabControl (see below for more information)Set the Content property of your NTWindow to your TabControlpublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       ...
 
       // TabControl should be created for window content if tab features are wanted
       TabControl tc = new TabControl();
 
       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs
       TabControlManager.SetIsMovable(tc, true);
       TabControlManager.SetCanAddTabs(tc, true);
       TabControlManager.SetCanRemoveTabs(tc, true);
 
       // if ability to add new tabs is desired, **TabControl** has to have attached property "Factory" set.
       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());
         
       Content = tc;
   }
} 
Note the instantiation of a new AddOnFrameworkWindowFactory in the example above. In this example, AddOnFrameworkWindowFactory is a custom class implementing the INTTabFactory interface. Within this class, the CreateParentWindow() and CreateTabPage() methods contained in INTTabFactory are hidden, as seen below:/* Class which implements **Tools.INTTabFactory** must be created and set as an attached property for **TabControl**
in order to use tab page add/remove/move/duplicate functionality */
public class AddOnFrameworkWindowFactory : INTTabFactory
{
   // **INTTabFactory** member. Required to create parent window
   public NTWindow CreateParentWindow()
   {
       return new AddOnFrameworkWindow();
   }
 
   // **INTTabFactory** member. Required to create tabs
   public NTTabPage CreateTabPage(string typeName, bool isTrue)
   {
       return new NinjaTraderAddOnProject.AddOnPage();
   }
} 
NoteTake note of the instantiation of the AddOnPage class in the example above. In our example, AddOnPage is a XAML-defined class. Thus, when CreateTabPage() is called on an instance of AddOnFrameworkWindowFactory, it instantiates our XAML-defined user interface. See below for more information on defining user interfaces in XAML.Creating an NTTabPage within an NTWindowWith an NTWindow defined and a TabControl set up, the next step is to instantiate an NTTabPage and add it to your TabControl. The first step is to define a class inheriting NTTabPage and implementing the IInstrumentProvid

[Content truncated...]


### Code Examples

#### Example 1

```csharp
/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
}
```

#### Example 2

```csharp
/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
}
```

#### Example 3

```csharp
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       ...
 
       // TabControl should be created for window content if tab features are wanted
       TabControl tc = new TabControl();
 
       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs
       TabControlManager.SetIsMovable(tc, true);
       TabControlManager.SetCanAddTabs(tc, true);
       TabControlManager.SetCanRemoveTabs(tc, true);
 
       // if ability to add new tabs is desired, **TabControl** has to have attached property "Factory" set.
       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());
         
       Content = tc;
   }
}
```

---

## 26. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/creating_your_own_addon_window

**Captured:** 2025-07-07T18:17:15.358Z

### Page Structure

- Creating Your Own AddOn Window
  - The NTWindow Class
  - Using TabControl for Tab Functionality
  - Note
  - Creating an NTTabPage within an NTWindow
  - Setting Up Workspace Persistence
  - Using XAML to Define Window Layout
  - Using C# to Define Window Layout
  - Launching Your Window From the Control Center
  - Adding NinjaTrader Custom Controls
    - 1. The Instrument Selector
    - 2. The Interval Selector
    - 3. The Quantity Up/Down Selector
    - 4. The Time-in-Force Selector
    - 5. The ATM Strategy Selector
      - Using the ATM Strategy Selector
  - Linking with Other Windows
      - ON THIS PAGE
- Creating Your Own AddOn Window
  - The NTWindow Class
  - Using TabControl for Tab Functionality
  - Note
  - Creating an NTTabPage within an NTWindow
  - Setting Up Workspace Persistence
  - Using XAML to Define Window Layout
  - Using C# to Define Window Layout
  - Launching Your Window From the Control Center
  - Adding NinjaTrader Custom Controls
    - 1. The Instrument Selector
    - 2. The Interval Selector
    - 3. The Quantity Up/Down Selector
    - 4. The Time-in-Force Selector
    - 5. The ATM Strategy Selector
      - Using the ATM Strategy Selector
  - Linking with Other Windows
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewCreating Your Own AddOn WindowDeveloping Add OnsOther Uses for an AddOnC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCreating Your Own AddOn WindowThe NTWindow ClassThe NTWindow class allows you to quickly build windows using the same style and skin as other windows in NinjaTrader. An NTWindow does not contain user-interface functionality, but rather serves as a container for instances of NTTabPage, which will contain controls and functionality for the window./* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
} 
Using TabControl for Tab FunctionalityAfter declaring an NTWindow, you can enable tab functionality on it (creating new tabs, copying tabs, etc.). The process for implementing tab functionality must be done within the constructor for your NTWindow, using the following process:Instantiate a new TabControl objectCall helper methods of the TabControlManager class, passing in your TabControl object as an argument, to enable specific functionalityUse the same approach as #2 to set an NTTabFactory for your TabControl (see below for more information)Set the Content property of your NTWindow to your TabControlpublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       ...
 
       // TabControl should be created for window content if tab features are wanted
       TabControl tc = new TabControl();
 
       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs
       TabControlManager.SetIsMovable(tc, true);
       TabControlManager.SetCanAddTabs(tc, true);
       TabControlManager.SetCanRemoveTabs(tc, true);
 
       // if ability to add new tabs is desired, **TabControl** has to have attached property "Factory" set.
       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());
         
       Content = tc;
   }
} 
Note the instantiation of a new AddOnFrameworkWindowFactory in the example above. In this example, AddOnFrameworkWindowFactory is a custom class implementing the INTTabFactory interface. Within this class, the CreateParentWindow() and CreateTabPage() methods contained in INTTabFactory are hidden, as seen below:/* Class which implements **Tools.INTTabFactory** must be created and set as an attached property for **TabControl**
in order to use tab page add/remove/move/duplicate functionality */
public class AddOnFrameworkWindowFactory : INTTabFactory
{
   // **INTTabFactory** member. Required to create parent window
   public NTWindow CreateParentWindow()
   {
       return new AddOnFrameworkWindow();
   }
 
   // **INTTabFactory** member. Required to create tabs
   public NTTabPage CreateTabPage(string typeName, bool isTrue)
   {
       return new NinjaTraderAddOnProject.AddOnPage();
   }
} 
NoteTake note of the instantiation of the AddOnPage class in the example above. In our example, AddOnPage is a XAML-defined class. Thus, when CreateTabPage() is called on an instance of AddOnFrameworkWindowFactory, it instantiates our XAML-defined user interface. See below for more information on defining user interfaces in XAML.Creating an NTTabPage within an NTWindowWith an NTWindow defined and a TabControl set up, the next step is to instantiate an NTTabPage and add it to your TabControl. The first step is to define a class inheriting NTTabPage and implementing the IInstrumentProvid

[Content truncated...]


### Code Examples

#### Example 1

```csharp
/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
}
```

#### Example 2

```csharp
/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.
    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar
       // This is the name displayed in the top-left of the window
       Caption = "AddOn Framework";
 
       // Set the initial dimensions of the window
       Width   = 1085;
       Height = 900;
   }
}
```

#### Example 3

```csharp
public class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence
{
   public AddOnFrameworkWindow()
   {
       ...
 
       // TabControl should be created for window content if tab features are wanted
       TabControl tc = new TabControl();
 
       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs
       TabControlManager.SetIsMovable(tc, true);
       TabControlManager.SetCanAddTabs(tc, true);
       TabControlManager.SetCanRemoveTabs(tc, true);
 
       // if ability to add new tabs is desired, **TabControl** has to have attached property "Factory" set.
       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());
         
       Content = tc;
   }
}
```

---

## 27. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/developing_add_ons

**Captured:** 2025-07-07T18:17:18.359Z

### Page Structure

- Developing Add Ons
  - Add Ons Overview
  - How to make Add Ons
      - ON THIS PAGE
- Developing Add Ons
  - Add Ons Overview
  - How to make Add Ons
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewCreating Your Own AddOn WindowDeveloping Add OnsOther Uses for an AddOnC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXDeveloping Add OnsAdd Ons OverviewAdd Ons are incredibly powerful NinjaScript objects that let you create unprecedented tools which are seamlessly integrated (visually and functionally) into NinjaTrader. Experienced programmers can leverage the information available through the framework to create exciting new windows and utilities that can give users an incredible edge over the markets.How to make Add OnsThe process to make an Add On is fairly simple once the structure is understood. A few questions should be answered to determine how to build your Add On:Where should the entry point for the Add On be? E.g. Should it be launched from the Control Center menus? Should it be launched from a Chart?Should the Add On leverage the tab functionality available in NinjaTrader?Should the Add On leverage the window linking functionality available in NinjaTrader?Should the Add On be persisted in NinjaTrader workspaces?Once the functionality of your Add On is determined you can use the following building blocks to create your Add On:Property/ClassDescriptionAddOnBaseThis is where you create the entry point for the Add On.NTWindowThis is where you define the parent window container for your Add On. Tabs would reside within this parent window should you choose. This is also where workspace persistence would be created.NTTabPageThis is where you define the content of each tab that resides inside NTWindow. This is also where you create the window linking functionality.Class implementing the INTTabFactory interfaceThis is necessary to ensure proper tab functionality like adding, removing, moving tabs around in your NTWindow.The general flow goes from AddOnBase > NTWindow > INTTabFactory > NTTabPage.AddOnBase determines the user entry point and then creates the event handler to create the NTWindow. NTWindow calls the tab factory which then brings in the NTTabPage content in the form of tabs into NTWindow.ON THIS PAGEAdd Ons OverviewHow to make Add OnsDeveloping Add OnsAdd Ons OverviewAdd Ons are incredibly powerful NinjaScript objects that let you create unprecedented tools which are seamlessly integrated (visually and functionally) into NinjaTrader. Experienced programmers can leverage the information available through the framework to create exciting new windows and utilities that can give users an incredible edge over the markets.How to make Add OnsThe process to make an Add On is fairly simple once the structure is understood. A few questions should be answered to determine how to build your Add On:Where should the entry point for the Add On be? E.g. Should it be launched from the Control Center menus? Should it be launched from a Chart?Should the Add On leverage the tab functionality available in NinjaTrader?Should the Add On leverage the window linking functionality available in NinjaTrader?Should the Add On be persisted in NinjaTrader workspaces?Once the functionality of your Add On is determined you can use the following building blocks to create your Add On:Property/ClassDescriptionAddOnBaseThis is where you create the entry point for the Add On.NTWindowThis is where you define the parent window container for your Add On. Tabs would reside within this parent window should you choose. This is also where workspace persistence would be created.NTTabPageThis is where you define the content of each tab that resides inside NTWindow. This is also where you create the window linking functionality.Class implementing the INTTabFactory interfaceThis is necessary to ensure proper tab functionality like adding, removing, moving tabs around in your NTWindow.The general flow goes from AddOnBase > NTWindow > INTTabFactory > NTTabPage.AddOnBase determines the user entry point and then creates the event handler to create the NTWindow. NTWindow calls the tab factory which then brings in the NTTabPage content in the form of tabs into NTWindow.ON THIS PAGEAdd Ons OverviewHow to make Add Ons

---

## 28. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/other_uses_for_an_addon

**Captured:** 2025-07-07T18:17:24.366Z

### Page Structure

- Other Uses for an AddOn
  - Modifying Existing NinjaTrader Windows
  - Accessing Account Data
  - Accessing Market Data
      - ON THIS PAGE
- Other Uses for an AddOn
  - Modifying Existing NinjaTrader Windows
  - Accessing Account Data
  - Accessing Market Data
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewCreating Your Own AddOn WindowDeveloping Add OnsOther Uses for an AddOnC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXOther Uses for an AddOnModifying Existing NinjaTrader WindowsTo modify an existing type of NinjaTrader window (for example, to add a button to all charts), you will first need to obtain a reference to each individual window of that type that is open. This can be done by overriding the OnWindowCreated() method, then declaring an object of the Type of the window you are looking for, and finally assigning the object a reference to the Window passed into the method:// OnWindowCreated() will be called any time a new NTWindow is created. It will be called in the thread of that window
protected override void OnWindowCreated(Window window)
{
   // Declare a Chart object and instantiate it to the Window passed into the method
   Gui.Chart.Chart myChart = window as Gui.Chart.Chart;
    
   // Use this check to return if the calling Window is not of the Type you are looking for
   if (myChart == null)
       return;
}
If you are unsure of the Type name for a particular type of window, you can open an instance of that window then run the code below, which will print the Type to the Output Window:protected override void OnWindowCreated(Window window)
{
   // Print the Type of any open windows, for future reference
   Print(window.ToString());
}
Once you've obtained a reference to a window, you can then directly manipulate the WPF grids, controls, and other elements to customize its user interface or functionality. For example, if your goal was to add a new button to Chart Trader on all charts, you could use your reference to Chart objects to first locate their attached Chart Trader instances, then place a custom-defined button directly into the WPF grid used to lay out buttons in Chart Trader. Since this code would run within OnWindowCreated(), it would be applied to every Chart Trader instance that is open. You would not be changing the format used to create Chart Traders in the first place, but would rather be detecting every open instance and adding the buttons into them. This is an important distinction to make, because this approach requires that you also remove the elements you've added when each window is destroyed.// Declare a Chart, ChartTrader, and UI elements to add to Chart Trader
Gui.Chart.Chart myChart;
Gui.Chart.ChartTrader chartTrader;
Button sampleButton;
Grid myGrid;
Grid mainGrid;
 
protected override void OnWindowCreated(Window window)
{
   // Instantiate myChart by assigning a reference to the calling Window
   myChart = window as Gui.Chart.Chart;
 
   if (myChart == null)
   {
       return;
   }
 
   //find chart trader from myChart's Chart Control by its Automation ID: "ChartWindowChartTrader"
   chartTrader = Window.GetWindow(myChart.ActiveChartControl.Parent).FindFirst("ChartWindowChartTraderControl") as Gui.Chart.ChartTrader;
 
   if (chartTrader == null)
   {
       return;
   }
 
   // Instantiate sampleButton
   sampleButton = new Button
   {
       Content = "Sample Button",
       Style = System.Windows.Application.Current.TryFindResource("Button") as Style
   };
 
   // Attach a custom event handler to the .Click event
   sampleButton.Click += SampleButton_Click;
 
   // Set a custom AutomationId for the button, so that it can be referenced elsewhere the same way we found Chart Trader
   System.Windows.Automation.AutomationProperties.SetAutomationId(sampleButton, "SampleButton");
 
   //this is the main chart trader grid where the default buttons and controls reside
   mainGrid = chartTrader.FindName("grdMain") as Grid;
 
   // Return if Chart Trader is null
   if (mainGrid == null)
   {
       return;
   }
 
   // by default, there will be 7 rows in Chart Trader, we need to add a new row for the new button
   if (mainGrid.RowDefinitions.Count <= 7)
       mainGrid.RowDefinitions.Add(new RowDefinition());
 
   //define a new grid, and add our button to that grid
   myGrid = new Grid();
   myGrid.Children.Add(sampleButton);
 
   //set my grid to the new row 
   Grid.SetRow(myGrid, 8);
 
   //finally, add our grid to the main grid
   m

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// OnWindowCreated() will be called any time a new NTWindow is created. It will be called in the thread of that window
protected override void OnWindowCreated(Window window)
{
   // Declare a Chart object and instantiate it to the Window passed into the method
   Gui.Chart.Chart myChart = window as Gui.Chart.Chart;
    
   // Use this check to return if the calling Window is not of the Type you are looking for
   if (myChart == null)
       return;
}
```

#### Example 2

```csharp
// OnWindowCreated() will be called any time a new NTWindow is created. It will be called in the thread of that window
protected override void OnWindowCreated(Window window)
{
   // Declare a Chart object and instantiate it to the Window passed into the method
   Gui.Chart.Chart myChart = window as Gui.Chart.Chart;
    
   // Use this check to return if the calling Window is not of the Type you are looking for
   if (myChart == null)
       return;
}
```

#### Example 3

```csharp
protected override void OnWindowCreated(Window window)
{
   // Print the Type of any open windows, for future reference
   Print(window.ToString());
}
```

---

## 29. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/c_method_functions_reference

**Captured:** 2025-07-07T18:17:37.357Z

### Page Structure

- C# Method (Functions) Reference
  - Native Methods
  - Note
  - Note
  - Note
      - ON THIS PAGE
- C# Method (Functions) Reference
  - Native Methods
  - Note
  - Note
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXC# Method (Functions) ReferenceNative MethodsThe Microsoft .NET environment has a rich class library that you can access when developing custom indicators and strategies. There is a plethora of information available online and in print that details class libraries in great depth. Below are quick links to the Microsoft Developers Network for some of the basic classes whose functionality you may harness when developing in NinjaScript.Complete list of classes in the Microsoft .NET environment.MSDN (Microsoft Developers Network) C# Language ReferenceKeywordsOperatorsArraysNoteSystem.Math Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions. Full list of member of the System.Math class.// Example of the Max method of the **System.Math** class
int myInteger = Math.Max(10, 20);
Print("The larger value between 10 and 20 is " + myInteger.ToString());
NoteSystem.DateTime Represents an instant in time, typically expressed as a date and time of day. Full list of members of the System.DateTime structure.// Example of the Now property member of the **System.DateTime** structure
DateTime startTime = DateTime.Now;
Print("Time elapsed is " + DateTime.Now.Subtract(startTime).TotalMilliseconds.ToString() + " milliseconds.");
NoteSystem.String Represents text; that is, a series of unicode characters. Full list of members of the System.String class.// Example of the ToUpper() method of the **System.String** class
string myString = "ninjatrader";
Print("The following word is in uppercase " + myString.ToUpper());
ON THIS PAGENative MethodsC# Method (Functions) ReferenceNative MethodsThe Microsoft .NET environment has a rich class library that you can access when developing custom indicators and strategies. There is a plethora of information available online and in print that details class libraries in great depth. Below are quick links to the Microsoft Developers Network for some of the basic classes whose functionality you may harness when developing in NinjaScript.Complete list of classes in the Microsoft .NET environment.MSDN (Microsoft Developers Network) C# Language ReferenceKeywordsOperatorsArraysNoteSystem.Math Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions. Full list of member of the System.Math class.// Example of the Max method of the **System.Math** class
int myInteger = Math.Max(10, 20);
Print("The larger value between 10 and 20 is " + myInteger.ToString());
NoteSystem.DateTime Represents an instant in time, typically expressed as a date and time of day. Full list of members of the System.DateTime structure.// Example of the Now property member of the **System.DateTime** structure
DateTime startTime = DateTime.Now;
Print("Time elapsed is " + DateTime.Now.Subtract(startTime).TotalMilliseconds.ToString() + " milliseconds.");
NoteSystem.String Represents text; that is, a series of unicode characters. Full list of members of the System.String class.// Example of the ToUpper() method of the **System.String** class
string myString = "ninjatrader";
Print("The following word is in uppercase " + myString.ToUpper());
ON THIS PAGENative Methods

### Code Examples

#### Example 1

```csharp
// Example of the Max method of the **System.Math** class
int myInteger = Math.Max(10, 20);
Print("The larger value between 10 and 20 is " + myInteger.ToString());
```

#### Example 2

```csharp
// Example of the Max method of the **System.Math** class
int myInteger = Math.Max(10, 20);
Print("The larger value between 10 and 20 is " + myInteger.ToString());
```

#### Example 3

```csharp
// Example of the Now property member of the **System.DateTime** structure
DateTime startTime = DateTime.Now;
Print("Time elapsed is " + DateTime.Now.Subtract(startTime).TotalMilliseconds.ToString() + " milliseconds.");
```

---

## 30. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/developing_for_tick_replay

**Captured:** 2025-07-07T18:17:41.348Z

### Page Structure

- Developing for Tick Replay
  - How to Enable Tick Replay
  - How the Tick Replay Engine Works
  - Accessing the current best bid and ask at the time of a trade
    - Accessing the current best bid and ask at the time of a trade
  - Calling a Tick Replay indicator from another Indicator or Strategy
    - Calling a Tick Replay indicator from another Indicator or Strategy
  - Note
      - ON THIS PAGE
- Developing for Tick Replay
  - How to Enable Tick Replay
  - How the Tick Replay Engine Works
  - Accessing the current best bid and ask at the time of a trade
    - Accessing the current best bid and ask at the time of a trade
  - Calling a Tick Replay indicator from another Indicator or Strategy
    - Calling a Tick Replay indicator from another Indicator or Strategy
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXDeveloping for Tick ReplayTick Replay is used to playback 1 tick historical data to build the bars as if they had been built live. This means that tick data will be thrown as Market Data events in historical and subsequently OnMarketData and OnBarUpdate events will be called as if it was live. This provides more granular tick-related information and can be helpful if you need to know the most recent last price, last volume, best ask price, or best bid price that occurred on historical data during the bar. An indicator or strategy running Tick Replay needs to have been specifically designed to take advantage of Tick Replay. In general, this means adding additional logic to the OnMarketData() event handler; however, Tick Replay can also be used to call OnBarUpdate(), OnEachTick, or OnPriceChange during historical calculations.How to Enable Tick ReplayTo enable tick replay, it must be manually enabled on the primary Data Series and the option to allow this mode is hidden by default. The option to allow for Tick Replay is located in Tools > Options > Market Data > "Show Tick Replay". The reason why it is hidden by default is that the tick replay engine utilizes 1 tick data to build historical bars. Tick Replay can generate thousands of events per bar and may take an excessive amount of time to load. It is recommended to optimize your indicators that you plan to calculate on such data by only running them in Calculate On Bar Close mode or reducing the amount of data to load to the minimum amount of data required. Since bars are built with tick data, you will only be able to build bars back as far as your historical data provider allows download of tick data.How the Tick Replay Engine WorksTick Replay guarantees an exact sequence of stored events are played back for both the OnBarUpdate and OnMarketData events. This mode also ensures the OnMarketData event is called after every OnBarUpdate event used to build the current bar. Consider the following examples with Tick Replay enabled on a 5-tick input series; each box is when each event occurs during Tick Replay simulation.As you can see from the table above, the Calculate setting will have a varying degree of impact on how your indicator or strategies OnBarUpdate event is raised. This process repeats for every historical bar on the chart and would continue as the indicator or strategy transitions to real-time data.Accessing the current best bid and ask at the time of a tradeNinjaTrader stores the best bid price and best ask price as the last trade occurs during the MarketDataType.Last event and provides it per the table below:marketDataUpdate.PriceThe current market data price of the last trade eventmarketDataUpdate.AskThe current asking price at the time of the last trade eventmarketDataUpdate.BidThe current bidding price at the time of the last trade eventmarketDataUpdate.VolumeThe current market data volume of the last trade eventmarketDataUpdate.TimeThe current time of the last trade eventAn example below shows how to access historical Bid and Ask prices with Tick Replay:Accessing the current best bid and ask at the time of a tradeprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)
{
    // TickReplay events only occur on the "Last" market data type
    if (marketDataUpdate.MarketDataType == MarketDataType.Last)
    {
        if (marketDataUpdate.Price >= marketDataUpdate.Ask)
        {
            Print(marketDataUpdate.Volume + " contracts traded at asking price " + marketDataUpdate.Ask);
        }
        else if (marketDataUpdate.Price <= marketDataUpdate.Bid)
        {
            Print(marketDataUpdate.Volume + " Contracts Traded at bidding price " + marketDataUpdate.Bid);
        }
    }
}
Calling a Tick Replay indicator from another Indicator or StrategyA hosting indicator or strategy must be aware of the requirement to run through another indicator's historical Tick Replay data before it reaches State.Historical. To achieve desired results, you either need to store the reference in State.DataLoaded or (for a strategy) you can call AddChartIndic

[Content truncated...]


### Code Examples

#### Example 1

```csharp
protected override void OnMarketData(MarketDataEventArgs marketDataUpdate)
{
    // TickReplay events only occur on the "Last" market data type
    if (marketDataUpdate.MarketDataType == MarketDataType.Last)
    {
        if (marketDataUpdate.Price >= marketDataUpdate.Ask)
        {
            Print(marketDataUpdate.Volume + " contracts traded at asking price " + marketDataUpdate.Ask);
        }
        else if (marketDataUpdate.Price <= marketDataUpdate.Bid)
        {
            Print(marketDataUpdate.Volume + " Contracts Traded at bidding price " + marketDataUpdate.Bid);
        }
    }
}
```

#### Example 2

```csharp
protected override void OnMarketData(MarketDataEventArgs marketDataUpdate)
{
    // TickReplay events only occur on the "Last" market data type
    if (marketDataUpdate.MarketDataType == MarketDataType.Last)
    {
        if (marketDataUpdate.Price >= marketDataUpdate.Ask)
        {
            Print(marketDataUpdate.Volume + " contracts traded at asking price " + marketDataUpdate.Ask);
        }
        else if (marketDataUpdate.Price <= marketDataUpdate.Bid)
        {
            Print(marketDataUpdate.Volume + " Contracts Traded at bidding price " + marketDataUpdate.Bid);
        }
    }
}
```

#### Example 3

```csharp
TickReplayIndicator myTickReplayIndicator = null;

protected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {
        Name = "TestHost";
    }
    else if (State == State.DataLoaded)
    {
        // Store a reference to the Tick Replay indicator before State.Historical
        // Doing so ensures the hosted indicator will run through Tick Replay
        myTickReplayIndicator = TickReplayIndicator();

        // For a strategy, you can just call AddChartIndicator(TickReplayIndicator());
        // However this also adds a copy of the indicator to the chart, which may or may not be desired
        // For calculation purposes only, storing the reference should all that needs to be required.
    }
}

protected override void OnBarUpdate()
{
    // Access the stored reference which calculates through
    // historical Tick Replay data and print the value as expected
    Print(myTickReplayIndicator[0]);
}
```

---

## 31. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/developing_outside_of_the_ninj

**Captured:** 2025-07-07T18:17:47.356Z

### Page Structure

- Developing Outside of the NinjaScript Editor
  - Developing Outside of the NinjaScript Editor
  - Note
      - ON THIS PAGE
- Developing Outside of the NinjaScript Editor
  - Developing Outside of the NinjaScript Editor
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXDeveloping Outside of the NinjaScript EditorDeveloping Outside of the NinjaScript EditorThe NinjaScript Editor automatically generates required program code on saving and/or compiling a custom indicator. If you choose to develop custom indicators outside of the NinjaScript Editor environment, please ensure that you use the NinjaScript Editor to compile.NotePlease see the additional information on this subject.ON THIS PAGEDeveloping Outside of the NinjaScript EditorDeveloping Outside of the NinjaScript EditorDeveloping Outside of the NinjaScript EditorThe NinjaScript Editor automatically generates required program code on saving and/or compiling a custom indicator. If you choose to develop custom indicators outside of the NinjaScript Editor environment, please ensure that you use the NinjaScript Editor to compile.NotePlease see the additional information on this subject.ON THIS PAGEDeveloping Outside of the NinjaScript Editor

---

## 32. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/set_up9

**Captured:** 2025-07-07T18:17:53.353Z

### Page Structure

- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE
- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingSet UpEntering Calculation LogicCompilingUsingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.Within the NinjaTrader Control Center, select the New menu, then select the NinjaScript Editor menu item.Right mouse click the "Indicators" folder in the NinjaScript Explorer section, then select the New Indicator menu item to open the New Indicator Wizard.Defining Indicator Properties and NameFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.Enter the information as shown above.Click the Next > button.Setting Default PropertiesThe next page will allow you to set defaults for basic properties related to your indicator, including its Calculate and Overlay settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below:Adding Additional DataThe next page will allow you to configure one or more additional Bars objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.Adding Event MethodsThe next page will allow you to pre-populate certain event methods into the NinjaScript code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.Defining Input ParametersThe next page will allow us to configure user input parameters for the indicator. For our custom CCI indicator, we will create a single input parameter which can be changed by users in the Indicators window when applying or editing the indicator. This input parameter will determine the CCI's period. We will select int as the Type, since integers are the most efficient native data types to be used for positive whole numbers, like those used to specify a number of bars to look back (a period). We will enter a "Default" value of "14" for the period, and a "Min" value of 1, to ensure that users do not enter zero or lower.Clicking the add button on the "Input Parameters" page brings up the Input Parameters dialogue.The Input Parameters dialogue can be used to define user inputs.Defining Plots and LinesThe next page will allow us to define plots and static lines for the indicator. For the CCI, we will define a single plot, called "CCI," and define five lines to draw in the indicator panel. For each item, first click the add button, then use the Plots and Lines dialogue to configure each item as seen below.The add button will allow you to configure plots and lines for the indicator.After this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to entering calculation logic.ON THIS PAGEDefining Indicator Properties and NameSetting Default PropertiesAdding Additional DataAdding Event MethodsDefining Input ParametersDefining Plots and LinesSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.Within the NinjaTrader Control Center, select the New menu, then select the NinjaScript Editor menu item.Right mouse click the "Indicators" folder in the NinjaScript Explorer section, then select the New Indicator menu item to open the New Indicator Wizard.Defining Indicator Properties and NameFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next

[Content truncated...]


---

## 33. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic6

**Captured:** 2025-07-07T18:17:57.353Z

### Page Structure

- Entering Calculation Logic
  - Entering Calculation Logic
  - Initializing the Indicator
  - Adding Core Indicator Logic
  - Custom Drawing
      - ON THIS PAGE
- Entering Calculation Logic
  - Entering Calculation Logic
  - Initializing the Indicator
  - Adding Core Indicator Logic
  - Custom Drawing
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingSet UpEntering Calculation LogicCompilingUsingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.The OnStateChange() method is called once before any bar data is loaded, and is used to configure the indicator (among other things).Initializing the IndicatorThe code below is automatically generated by the wizard and added to the OnStateChange() method, within State.SetDefaults. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:AddPlot(Brushes.Orange, "MyPlot");
AddLine(Brushes.DimGray, 200, "Level 2");
AddLine(Brushes.DimGray, 100, "Level 1");
AddLine(Brushes.DimGray, 0, "Zero Line");
AddLine(Brushes.DimGray, -100, "Level -1");
AddLine(Brushes.DimGray, -200, "Level -2");
To change the visual properties of the Zero Line, replace the fourth line in the code above with the line below. This will change the color to black and the line style to "dash:"AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, "Zero Line");
The code above uses an alternative method overload (an alternative set of arguments passed in to the AddLine() method), in order to pass in a Stroke object rather than a Brush. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via DashStyleHelper) and the line width. After this change, your configured lines and plots should look like this:AddPlot(Brushes.Orange, "MyCCI_Plot");
AddLine(Brushes.DimGray, 200, "Level 2");
AddLine(Brushes.DimGray, 100, "Level 1");
AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, "Zero Line");
AddLine(Brushes.DimGray, -100, "Level -1");
AddLine(Brushes.DimGray, -200, "Level -2");
Adding Core Indicator LogicSince this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the @CCI indicator already built-in to NinjaTrader.The @CCI indicator uses an SMA object in its calculations. To add this, copy the line below from @CCI into your custom CCI, directly below the class declaration:private SMA sma;
Next, copy the following initialization for the SMA object into the OnStateChange() method, within State.DataLoaded:
sma = SMA(Typical, Period);
Next, copy the core calculation logic from @CCI into the OnBarUpdate() method of your custom indicator:if (CurrentBar == 0)
   Value[0] = 0;
else
{
   double mean = 0;
   double sma0 = sma[0];

   for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)
       mean += Math.Abs(Typical[idx] - sma0);

   Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));
}
The code for your MyCCI class should now look as follows (in addition to the using statements and class declaration):
public class MyCCI : Indicator
{
   private SMA sma;

   protected override void OnStateChange()
   {
       if (State == State.SetDefaults)
       {
           Description = @"NinjaScript Custom Drawing Indicator Tutorial";
           Name = "MyCCI";
           Calculate = Calculate.OnBarClose;
           IsOverlay = false;
           DisplayInDataBox = true;
           DrawOnPricePanel = true;
           DrawHorizontalGridLines = true;
           DrawVerticalGr

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddPlot(Brushes.Orange, "MyPlot");
AddLine(Brushes.DimGray, 200, "Level 2");
AddLine(Brushes.DimGray, 100, "Level 1");
AddLine(Brushes.DimGray, 0, "Zero Line");
AddLine(Brushes.DimGray, -100, "Level -1");
AddLine(Brushes.DimGray, -200, "Level -2");
```

#### Example 2

```csharp
AddPlot(Brushes.Orange, "MyPlot");
AddLine(Brushes.DimGray, 200, "Level 2");
AddLine(Brushes.DimGray, 100, "Level 1");
AddLine(Brushes.DimGray, 0, "Zero Line");
AddLine(Brushes.DimGray, -100, "Level -1");
AddLine(Brushes.DimGray, -200, "Level -2");
```

#### Example 3

```csharp
AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, "Zero Line");
```

---

## 34. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling6

**Captured:** 2025-07-07T18:18:00.366Z

### Page Structure

- Compiling
  - Compiling
      - ON THIS PAGE
- Compiling
  - Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingSet UpEntering Calculation LogicCompilingUsingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator by selecting the Compile menu item from within the NinjaScript Editor Right Click, by clicking the Compile icon on the toolbar at the top of the window, or by pressing the F5 key on your keyboard. It is important to understand that this process makes the indicator ready for real-time use natively within NinjaTrader. It does not run as interpreted code, as many other applications do, but rather as a C# assembly. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator by selecting the Compile menu item from within the NinjaScript Editor Right Click, by clicking the Compile icon on the toolbar at the top of the window, or by pressing the F5 key on your keyboard. It is important to understand that this process makes the indicator ready for real-time use natively within NinjaTrader. It does not run as interpreted code, as many other applications do, but rather as a C# assembly. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompiling

---

## 35. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using6

**Captured:** 2025-07-07T18:18:03.354Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingSet UpEntering Calculation LogicCompilingUsingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 36. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/set_up8

**Captured:** 2025-07-07T18:18:09.350Z

### Page Structure

- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE
- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsSet UpEntering Calculation LogicCompilingUsingIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.Within the NinjaTrader Control Center, select the New menu, then select the NinjaScript Editor menu item.Right mouse click the "Indicators" folder in the NinjaScript Explorer section, then select the New Indicator menu item to open the New Indicator Wizard.Defining Indicator Properties and NameFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.Enter the information as shown above.Click the Next > button.Setting Default PropertiesThe next page will allow you to set defaults for basic properties related to your indicator, including its Calculate and Overlay settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.Adding Additional DataThe next page will allow you to configure one or more additional Bars objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.Adding Event MethodsThe next page will allow you to pre-populate certain event methods into the NinjaScript code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.Defining Input ParametersThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the Close price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it "Periods." This variable will then be used to determine the number of bars used in the plot calculation.Clicking the add button on the "Input Parameters" page brings up the Input Parameters dialogue.The Input Parameters dialogue can be used to define user inputs.Click the add button again on the "Input Parameters" page and enter the information detailed in the Input Parameters dialogue marked 3.We specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for Periods.Defining Plots and LinesThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define 1 line and 2 plots and a line, called "Zero."Clicking the add button on the "Plots and Lines" page brings up the Plots and Lines dialogue.The Plots and Lines dialogue can be used to define the ZeroLine.Click the add button again on the "Plots and Lines" page and enter the information detailed in the Plots and Lines window marked 3 to add the AboveZero plot.Click the add button once more on the "Plots and Lines" page and enter the information detailed in the Plots and Lines window marked 4 to add the BelowZero plot.After this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to entering calculation logic.ON THIS PAGEDefining Indicator Properties and NameSetting Default PropertiesAdding Additional DataAdding Event MethodsDefining Input ParametersDefining Plots and LinesSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the req

[Content truncated...]


---

## 37. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic5

**Captured:** 2025-07-07T18:18:13.348Z

### Page Structure

- Entering Calculation Logic
  - Setting Plot Thresholds
  - Completing the Indicator
      - ON THIS PAGE
- Entering Calculation Logic
  - Setting Plot Thresholds
  - Completing the Indicator
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsSet UpEntering Calculation LogicCompilingUsingIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate the ROC value.Setting Plot ThresholdsThe OnStateChange() method is called once before any bar data is loaded and is used to configure the indicator. The code below is automatically generated by the wizard and added to the OnStateChange() method. It configures the indicator for two plots and one line and sets the parameters.AddLine(Brushes.Black, 0, "ZeroLine");
AddPlot(Brushes.Green, "AboveZero");
AddPlot(Brushes.OrangeRed, "BelowZero");
Enter the following code in the OnStateChange() method and below the wizard generated code:// Set the threshold values for each plot
Plots[0].Min = 0;
Plots[1].Max = 0;
The concept of setting threshold values is to set when and when not to paint a plot on the chart. In this indicator, we have an "AboveZero" plot with a default color of green which we only want to see when the value of ROC is above zero and a "BelowZero" plot with a default color of OrangeRed which we only want to see when the value of ROC is below zero. In order to make that happen we have to set the threshold values of each plot.Plots[0].Min = 0;This statement says, in the collection of Plot objects, take the first one (Plots[0]) and set its minimum value to zero. This means any value below zero will not display.Plots[1].Max = 0;This statement says, in the collection of Plot objects, take the second one (Plots[1]) and set its maximum value to zero. This means any value above zero will not display.We now have a simple plot switching mechanism that displays the correct colored line depending on if the value of ROC is above or below zero. In fact, you can take this concept a little bit farther. You can even set different plots style (bar, dot etc..) depending on threshold values.A quick word about collections. Collections are objects that store a collection of objects, kind of like a container. In this case we are working with a collection of plots. In the above wizard generated code you will notice that we are adding new plots to the "Plots" collection. "AboveZero" was added first and then "BelowZero". This means that we can reference the "AboveZero" plot object through Plots[0]. The reason we don't pass in a value of 1 is because collections are zero based indexes. This means the first item has an index of 0, the second time an index of 1 and so forth.Completing the IndicatorThis indicator is actually quite simple in its implementation. The last thing we need to do is add the calculation code and set the value of ROC to both our plot lines.Replace the wizard generated code with the following code into the OnBarUpdate() method in the NinjaScript Editor:
// Are there enough bars
if (CurrentBar < Period) return;

// Set the plot values
AboveZero[0] = SMA(ROC(Period), Smooth)[0];
BelowZero[0] = SMA(ROC(Period), Smooth)[0];
The calculation first checks to ensure there are enough bars to complete the calculation and then sets both plot lines to the ROC value.The class code in your editor should look identical to the image below. You are now ready to compile the indicator and configure it on a chart.
public class CustomROC : Indicator
{
    protected override void OnStateChange()
    {
        if (State == State.SetDefaults)
        {
            Description = @"ROC with custom line color options";
            Name = "CustomROC";
            Calculate =

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddLine(Brushes.Black, 0, "ZeroLine");
AddPlot(Brushes.Green, "AboveZero");
AddPlot(Brushes.OrangeRed, "BelowZero");
```

#### Example 2

```csharp
AddLine(Brushes.Black, 0, "ZeroLine");
AddPlot(Brushes.Green, "AboveZero");
AddPlot(Brushes.OrangeRed, "BelowZero");
```

#### Example 3

```csharp
// Set the threshold values for each plot
Plots[0].Min = 0;
Plots[1].Max = 0;
```

---

## 38. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling5

**Captured:** 2025-07-07T18:18:17.359Z

### Page Structure

- Compiling
  - Compiling
      - ON THIS PAGE
- Compiling
  - Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsSet UpEntering Calculation LogicCompilingUsingIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompiling

---

## 39. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using5

**Captured:** 2025-07-07T18:18:20.396Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsSet UpEntering Calculation LogicCompilingUsingIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 40. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/set_up7

**Captured:** 2025-07-07T18:18:26.357Z

### Page Structure

- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE
- Set Up
  - Defining Indicator Properties and Name
  - Setting Default Properties
  - Adding Additional Data
  - Adding Event Methods
  - Defining Input Parameters
  - Defining Plots and Lines
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesSet UpEntering Calculation LogicCompilingUsingIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.Within the NinjaTrader Control Center, select the New menu, then select the NinjaScript Editor menu item.Right mouse click the "Indicators" folder in the NinjaScript Explorer section, then select the New Indicator menu item to open the New Indicator Wizard.Defining Indicator Properties and NameFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.Enter the information as shown above.Click the Next > button.Setting Default PropertiesThe next page will allow you to set defaults for basic properties related to your indicator, including its Calculate and Overlay settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.Adding Additional DataThe next page will allow you to configure one or more additional Bars objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.Here we will click the arrow or the bold Custom Series text to be able to use the wizard to add our custom Series<t> object.Once the menu is expanded, we can click the add button to add a Series<t>.We will then enter the information above, and select Double as the variable type for the Series<t>.Adding Event MethodsThe next page will allow you to pre-populate certain event methods into the NinjaScript code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.Defining Input ParametersThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the Close price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it "Periods." This variable will then be used to determine the number of bars used in the plot calculation.Clicking the add button on the "Input Parameters" page brings up the Input Parameters dialogue.The Input Parameters dialogue can be used to define user inputs.We specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for Periods.Defining Plots and LinesThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define a single plot, called "MyPlot."Clicking the add button on the "Plots and Lines" page brings up the Plots and Lines dialogue.The Plots and Lines dialogue can be used to define the plot.After this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to entering calculation logic.ON THIS PAGEDefining Indicator Properties and NameSetting Default PropertiesAdding Additional DataAdding Event MethodsDefining Input ParametersDefining Plots and LinesSet UpThe first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.Within the NinjaTrader Control Center, select the New menu, then select the NinjaScript Edi

[Content truncated...]


---

## 41. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic4

**Captured:** 2025-07-07T18:18:31.356Z

### Page Structure

- Entering Calculation Logic
  - Creating the Series<double> Object
      - ON THIS PAGE
- Entering Calculation Logic
  - Creating the Series<double> Object
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesSet UpEntering Calculation LogicCompilingUsingIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will do our calculations.Creating the Series<double> ObjectDeclare a variable (MySeries used in this example) of type Series<double> that will hold a Series<double> object within the region "Variables".Create a new Series<double> object and assign it to the MySeries variable within the OnStateChange() method.private Series<double> MySeries;
protected override void OnStateChange()
{
 if (State == State.SetDefaults)
 {
   ...
 }
 else if (State == State.DataLoaded)
 {
   MySeries = new Series<double>(this);
 }
}
Storing calculations in the DataSeries objectNow that we have our Series<double> object we can store double values into it. For this example we will store a simple Close minus Open calculation.Enter the following code into the OnBarUpdate() method:// Calculate the range of the current bar and set the value
MySeries[0] = Close[0] - Open[0];
The value of a Series<t> object will be aligned with the current bar. This means that all Series<t> objects will be synced with the CurrentBar index. It allows you to store A double value that corresponds with every bar.Using Series<t> valuesWith our new Series<double> object we can continue with further calculations easily. We can now use our Series<double> object as input to an indicator method such as SMA or instead of always writing Close[0] - Open[0] we can substitute our Series<double> object instead as per the example below.To plot our final calculation we will store the calculation in our plot called MyPlot. In the OnBarUpdate() method add the following code snippet:// Add the bar's range to the SMA value
MyPlot[0] = SMA(SMAPeriod)[0] + MySeries[0];
Here we assign the SMA + Series<double> value to the property that represents the plot data using the "=" assignment operator. We have just finished coding our CustomSeries example. The class code in your editor should look identical to the below. You are now ready to compile the indicator and configure it on a chart.public class CustomSeries : Indicator
{
   private Series<double> MySeries;

   protected override void OnStateChange()
   {
     if (State == State.SetDefaults)
     {
         Description                     = @"Stores intermediary calculations without the use of plots";
         Name                             = "CustomSeries";
         Calculate                         = Calculate.OnBarClose;
         IsOverlay                         = false;
         DisplayInDataBox                 = true;
         DrawOnPricePanel                 = true;
         DrawHorizontalGridLines           = true;
         DrawVerticalGridLines             = true;
         PaintPriceMarkers                 = true;
         ScaleJustification                 = NinjaTrader.Gui.Chart.ScaleJustification.Right;
         //Disable this property if your indicator requires custom values that cumulate with each new market data event.
         //See Help Guide for additional information.
         IsSuspendedWhileInactive         = true;
         SMAPeriod                         = 5;
         AddPlot(Brushes.Orange, "MyPlot");
     }
     else if (State == State.Configure)
     {
     }
     else if (State == State.DataLoaded)
     {
         MySeries = new Series<double>(this);
     }
   }

   protected override void OnBarUpdate()
   {
     // Calculate the range of the current ba

[Content truncated...]


### Code Examples

#### Example 1

```csharp
private Series<double> MySeries;
protected override void OnStateChange()
{
 if (State == State.SetDefaults)
 {
   ...
 }
 else if (State == State.DataLoaded)
 {
   MySeries = new Series<double>(this);
 }
}
```

#### Example 2

```csharp
private Series<double> MySeries;
protected override void OnStateChange()
{
 if (State == State.SetDefaults)
 {
   ...
 }
 else if (State == State.DataLoaded)
 {
   MySeries = new Series<double>(this);
 }
}
```

#### Example 3

```csharp
// Calculate the range of the current bar and set the value
MySeries[0] = Close[0] - Open[0];
```

---

## 42. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling4

**Captured:** 2025-07-07T18:18:34.357Z

### Page Structure

- Compiling
  - Compiling
      - ON THIS PAGE
- Compiling
  - Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesSet UpEntering Calculation LogicCompilingUsingIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompiling

---

## 43. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using4

**Captured:** 2025-07-07T18:18:37.358Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesSet UpEntering Calculation LogicCompilingUsingIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 44. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic3

**Captured:** 2025-07-07T18:18:44.357Z

### Page Structure

- Entering Calculation Logic
  - Entering Calculation Logic
  - Are there enough bars?
  - Getting a sum of closing prices
  - The final calculation
  - Alternate Implementation
      - ON THIS PAGE
- Entering Calculation Logic
  - Entering Calculation Logic
  - Are there enough bars?
  - Getting a sum of closing prices
  - The final calculation
  - Alternate Implementation
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMASet UpEntering Calculation LogicCompilingUsingBeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate a simple moving average.Are there enough bars?Enter the following code into the OnBarUpdate() method in the NinjaScript Editor:// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
To calculate a 20 period moving average you will need a minimum of 20 bars of data. The first statement in our OnBarUpdate() method checks to see if there are enough bars of data to perform the moving average calculation. CurrentBar returns the index number of the current bar and this is checked against the user-defined parameter Period. If the current bar number is less than the user-defined period we "return" which skips calculating the moving average.Getting a sum of closing pricesEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Get a sum of prices over the specified period
double sum = 0; 
for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
First we must declare a variable that will store our sum total.double sum = 0;
The variable sum whose value is of type double will serve as temporary storage.for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
Next we must calculate the sum. We use a standard "for" loop to skip through prices and add them to the sum variable. Although the command that represents the loop may look intimidating, it's really quite simple. Let's look at it in English....What the loop is saying is:the number of bars ago is now zeroas long as the number of bars ago is less than the moving average period, then go to line 3 otherwise this loop is finishedget the price Input[number of bars ago] and add it to the running sum totaladd one to the number of bars ago (if number of bars ago was zero it will now be one)go to line 2You can find more information on how loops work here. Once the loop has finished, it will have calculated the total sum of closing prices for the period of our moving average.We use the value of Input[barsAgo] to get a price to use for our calculation. We could have substituted Close[barsAgo] to use closing prices or High[barsAgo] to use high prices. The reason we use Input[barsAgo] is since this allows flexibility for what the indicator is calculated based off of. Remember users have the option to select a price type (High, Open, Close etc...) from the Indicator Dialog window.The final calculationEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Calculate and set the average value to the 'MyPlot' property
MyPlot[0] = sum / Period;
We can now calculate the final moving average value and assign its value to the property that represents the plot data. We have just finished coding our simple moving average. The class code in your editor should look identical to the image below. You are now ready to compile the indicator.public class MySMA : Indicator
{
   protected override void OnStateChange()
   {
     if (State == State.SetDefaults)
     {
         Description                     = @"Simple Moving Average";
         Name                             = "MySMA";
         Calculate                         = Calculate.OnBarClose;
         IsOverlay                         = true;
         DisplayInDataBox  

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
```

#### Example 2

```csharp
// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
```

#### Example 3

```csharp
// Get a sum of prices over the specified period
double sum = 0; 
for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
```

---

## 45. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic3

**Captured:** 2025-07-07T18:18:46.359Z

### Page Structure

- Entering Calculation Logic
  - Entering Calculation Logic
  - Are there enough bars?
  - Getting a sum of closing prices
  - The final calculation
  - Alternate Implementation
      - ON THIS PAGE
- Entering Calculation Logic
  - Entering Calculation Logic
  - Are there enough bars?
  - Getting a sum of closing prices
  - The final calculation
  - Alternate Implementation
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMASet UpEntering Calculation LogicCompilingUsingBeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate a simple moving average.Are there enough bars?Enter the following code into the OnBarUpdate() method in the NinjaScript Editor:// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
To calculate a 20 period moving average you will need a minimum of 20 bars of data. The first statement in our OnBarUpdate() method checks to see if there are enough bars of data to perform the moving average calculation. CurrentBar returns the index number of the current bar and this is checked against the user-defined parameter Period. If the current bar number is less than the user-defined period we "return" which skips calculating the moving average.Getting a sum of closing pricesEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Get a sum of prices over the specified period
double sum = 0; 
for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
First we must declare a variable that will store our sum total.double sum = 0;
The variable sum whose value is of type double will serve as temporary storage.for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
Next we must calculate the sum. We use a standard "for" loop to skip through prices and add them to the sum variable. Although the command that represents the loop may look intimidating, it's really quite simple. Let's look at it in English....What the loop is saying is:the number of bars ago is now zeroas long as the number of bars ago is less than the moving average period, then go to line 3 otherwise this loop is finishedget the price Input[number of bars ago] and add it to the running sum totaladd one to the number of bars ago (if number of bars ago was zero it will now be one)go to line 2You can find more information on how loops work here. Once the loop has finished, it will have calculated the total sum of closing prices for the period of our moving average.We use the value of Input[barsAgo] to get a price to use for our calculation. We could have substituted Close[barsAgo] to use closing prices or High[barsAgo] to use high prices. The reason we use Input[barsAgo] is since this allows flexibility for what the indicator is calculated based off of. Remember users have the option to select a price type (High, Open, Close etc...) from the Indicator Dialog window.The final calculationEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Calculate and set the average value to the 'MyPlot' property
MyPlot[0] = sum / Period;
We can now calculate the final moving average value and assign its value to the property that represents the plot data. We have just finished coding our simple moving average. The class code in your editor should look identical to the image below. You are now ready to compile the indicator.public class MySMA : Indicator
{
   protected override void OnStateChange()
   {
     if (State == State.SetDefaults)
     {
         Description                     = @"Simple Moving Average";
         Name                             = "MySMA";
         Calculate                         = Calculate.OnBarClose;
         IsOverlay                         = true;
         DisplayInDataBox  

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
```

#### Example 2

```csharp
// Do not calculate if we don't have enough bars 
if (CurrentBar < Period) return;
```

#### Example 3

```csharp
// Get a sum of prices over the specified period
double sum = 0; 
for (int barsAgo = 0; barsAgo < Period; barsAgo++) 
{ 
   sum = sum + Input[barsAgo]; 
}
```

---

## 46. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling3

**Captured:** 2025-07-07T18:18:49.370Z

### Page Structure

- Compiling
      - ON THIS PAGE
- Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMASet UpEntering Calculation LogicCompilingUsingBeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGE

---

## 47. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using3

**Captured:** 2025-07-07T18:18:52.351Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMASet UpEntering Calculation LogicCompilingUsingBeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 48. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic2

**Captured:** 2025-07-07T18:18:58.369Z

### Page Structure

- Entering Calculation Logic
  - Calculating the Average
  - Final Assignment
      - ON THIS PAGE
- Entering Calculation Logic
  - Calculating the Average
  - Final Assignment
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorSet UpEntering Calculation LogicCompilingUsingBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (calculating an average of volume) within this method.Calculating the AverageNinjaTrader has built in indicators that you can reference in your calculations. Since we are calculating a simple moving average of volume it would make sense for us to use the built in SMA indicator and Volume indicators.Enter the following code into the OnBarUpdate() method in the NinjaScript Editor:// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
Here we declared the variable "average" which is of type double. This serves as the temporary storage for the current value of the simple moving average of volume. We then use the simple moving average indicator and pass in the volume indicator as its input, pass in our indicator "Periods" property (a parameter we defined in the wizard) and access the current value "[0]" that we will assign to our variable "average". If we wanted to assign the value one bar ago, we could have used "[1]".Final AssignmentEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Set the calculated value to the plot
MyPlot[0] = average;
Here we assign the "average" value to the property that represents the plot data using the '=' assignment operator. We have just finished coding our simple moving average of volume. Your class code should look identical to the code below. You are now ready to compile the indicator and configure it on a chart.public class VolSMA : Indicator
{
   protected override void OnStateChange()
   {
     if (State == State.SetDefaults)
     {
         Description                     = @"Moving average of volume";
         Name                             = "VolSMA";
         Calculate                         = Calculate.OnBarClose;
         IsOverlay                         = false;
         DisplayInDataBox                 = true;
         DrawOnPricePanel                 = true;
         DrawHorizontalGridLines           = true;
         DrawVerticalGridLines             = true;
         PaintPriceMarkers                 = true;
         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;
         //Disable this property if your indicator requires custom values that cumulate with each new market data event. 
         //See Help Guide for additional information.
         IsSuspendedWhileInactive         = true;
         Periods                           = 10;
         AddPlot(Brushes.Orange, "MyPlot");
     }
     else if (State == State.Configure)
     {
     }
   }
   protected override void OnBarUpdate()
   {
     // Calculate the volume average
     double average = SMA(VOL(), Periods)[0];
     // Set the calculated value to the plot
     MyPlot[0] = average;
   }
   #region Properties
   [NinjaScriptProperty]
   [Range(1, int.MaxValue)]
   [Display(Name="Periods", Description="Number of periods", Order=1, GroupName="Parameters")]
   public int Periods
   { get; set; }
   [Browsable(false)]
   [XmlIgnore]
    public Series<double> MyPlot
   {
     get { return Values[0]; }
   }
   #endregion
ON THIS PAGECalculating the AverageFinal AssignmentEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
```

#### Example 2

```csharp
// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
```

#### Example 3

```csharp
// Set the calculated value to the plot
MyPlot[0] = average;
```

---

## 49. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic2

**Captured:** 2025-07-07T18:19:00.372Z

### Page Structure

- Entering Calculation Logic
  - Calculating the Average
  - Final Assignment
      - ON THIS PAGE
- Entering Calculation Logic
  - Calculating the Average
  - Final Assignment
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorSet UpEntering Calculation LogicCompilingUsingBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (calculating an average of volume) within this method.Calculating the AverageNinjaTrader has built in indicators that you can reference in your calculations. Since we are calculating a simple moving average of volume it would make sense for us to use the built in SMA indicator and Volume indicators.Enter the following code into the OnBarUpdate() method in the NinjaScript Editor:// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
Here we declared the variable "average" which is of type double. This serves as the temporary storage for the current value of the simple moving average of volume. We then use the simple moving average indicator and pass in the volume indicator as its input, pass in our indicator "Periods" property (a parameter we defined in the wizard) and access the current value "[0]" that we will assign to our variable "average". If we wanted to assign the value one bar ago, we could have used "[1]".Final AssignmentEnter the following code into the OnBarUpdate() method and below the code snippet you entered above:// Set the calculated value to the plot
MyPlot[0] = average;
Here we assign the "average" value to the property that represents the plot data using the '=' assignment operator. We have just finished coding our simple moving average of volume. Your class code should look identical to the code below. You are now ready to compile the indicator and configure it on a chart.public class VolSMA : Indicator
{
   protected override void OnStateChange()
   {
     if (State == State.SetDefaults)
     {
         Description                     = @"Moving average of volume";
         Name                             = "VolSMA";
         Calculate                         = Calculate.OnBarClose;
         IsOverlay                         = false;
         DisplayInDataBox                 = true;
         DrawOnPricePanel                 = true;
         DrawHorizontalGridLines           = true;
         DrawVerticalGridLines             = true;
         PaintPriceMarkers                 = true;
         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;
         //Disable this property if your indicator requires custom values that cumulate with each new market data event. 
         //See Help Guide for additional information.
         IsSuspendedWhileInactive         = true;
         Periods                           = 10;
         AddPlot(Brushes.Orange, "MyPlot");
     }
     else if (State == State.Configure)
     {
     }
   }
   protected override void OnBarUpdate()
   {
     // Calculate the volume average
     double average = SMA(VOL(), Periods)[0];
     // Set the calculated value to the plot
     MyPlot[0] = average;
   }
   #region Properties
   [NinjaScriptProperty]
   [Range(1, int.MaxValue)]
   [Display(Name="Periods", Description="Number of periods", Order=1, GroupName="Parameters")]
   public int Periods
   { get; set; }
   [Browsable(false)]
   [XmlIgnore]
    public Series<double> MyPlot
   {
     get { return Values[0]; }
   }
   #endregion
ON THIS PAGECalculating the AverageFinal AssignmentEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
```

#### Example 2

```csharp
// Calculate the volume average
double average = SMA(VOL(), Periods)[0];
```

#### Example 3

```csharp
// Set the calculated value to the plot
MyPlot[0] = average;
```

---

## 50. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling2

**Captured:** 2025-07-07T18:19:03.351Z

### Page Structure

- Compiling
  - Compiling
      - ON THIS PAGE
- Compiling
  - Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorSet UpEntering Calculation LogicCompilingUsingBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingCompilingCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompiling

---

## 51. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using2

**Captured:** 2025-07-07T18:19:07.348Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorSet UpEntering Calculation LogicCompilingUsingBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 52. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic

**Captured:** 2025-07-07T18:19:14.350Z

### Page Structure

- Entering Calculation Logic
  - Adding the Condition and Assigning the Plot Value
      - ON THIS PAGE
- Entering Calculation Logic
  - Adding the Condition and Assigning the Plot Value
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesSet UpEntering Calculation LogicCompilingUsingDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.Adding the Condition and Assigning the Plot ValueEnter the following code in the OnBarUpdate() method in the NinjaScript Editor:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
Although the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a Ternary Operator, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to BarsAgo. We do this by using Values, which is a collection holding values for all plots configured in the indicator: Values[0][BarsAgo] =
Next, we add a condition to test. In this case, we are testing to see whether Close at a bar index corresponding to the value of BarsAgo was greater than Close at a value of BarsAgo + 1. If BarsAgo was set to 5, for example, this would compare Close[5] to Close[6]:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ?
If the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon ":"), which will assign the value of the indicator plot to the High price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the TickSize property:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) :
If the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon ":", which will assign the value of the indicator plot to the Low price of the specified bar, less five ticks:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
The core indicator logic is now in place, but running this code as it is can result in an "Index out of range" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if BarsAgo were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:if(CurrentBar < BarsAgo + 1)
   return;
This line says, "if there is not a number of bars equal to one number greater than the value of BarsAgo, then exit OnBarUpdate()."Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart:public class PriceVariableTutorial : Indicator
{
   protected override void OnStateChange()
   {
       if (State == State.SetDefaults)
       {
           Description                     = @"NinjaScript Price Variables Tutorial";
           Name                  

[Content truncated...]


### Code Examples

#### Example 1

```csharp
Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
```

#### Example 2

```csharp
Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
```

#### Example 3

```csharp
Values[0][BarsAgo] =
```

---

## 53. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_calculation_logic

**Captured:** 2025-07-07T18:19:15.396Z

### Page Structure

- Entering Calculation Logic
  - Adding the Condition and Assigning the Plot Value
      - ON THIS PAGE
- Entering Calculation Logic
  - Adding the Condition and Assigning the Plot Value
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesSet UpEntering Calculation LogicCompilingUsingDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Calculation LogicThe OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.Adding the Condition and Assigning the Plot ValueEnter the following code in the OnBarUpdate() method in the NinjaScript Editor:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
Although the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a Ternary Operator, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to BarsAgo. We do this by using Values, which is a collection holding values for all plots configured in the indicator: Values[0][BarsAgo] =
Next, we add a condition to test. In this case, we are testing to see whether Close at a bar index corresponding to the value of BarsAgo was greater than Close at a value of BarsAgo + 1. If BarsAgo was set to 5, for example, this would compare Close[5] to Close[6]:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ?
If the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon ":"), which will assign the value of the indicator plot to the High price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the TickSize property:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) :
If the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon ":", which will assign the value of the indicator plot to the Low price of the specified bar, less five ticks:Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
The core indicator logic is now in place, but running this code as it is can result in an "Index out of range" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if BarsAgo were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:if(CurrentBar < BarsAgo + 1)
   return;
This line says, "if there is not a number of bars equal to one number greater than the value of BarsAgo, then exit OnBarUpdate()."Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart:public class PriceVariableTutorial : Indicator
{
   protected override void OnStateChange()
   {
       if (State == State.SetDefaults)
       {
           Description                     = @"NinjaScript Price Variables Tutorial";
           Name                  

[Content truncated...]


### Code Examples

#### Example 1

```csharp
Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
```

#### Example 2

```csharp
Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize));
```

#### Example 3

```csharp
Values[0][BarsAgo] =
```

---

## 54. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling

**Captured:** 2025-07-07T18:19:21.349Z

### Page Structure

- Compiling
      - ON THIS PAGE
- Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesSet UpEntering Calculation LogicCompilingUsingDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the NinjaScript Editor right mouse button menu "Compile" menu or simply press the F5 key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGE

---

## 55. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using

**Captured:** 2025-07-07T18:19:25.358Z

### Page Structure

- Using
      - ON THIS PAGE
- Using
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesSet UpEntering Calculation LogicCompilingUsingDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGEUsingYour indicator is now ready for use and will be listed in the Indicator Dialog window.The indicator can now be found in the "Available" section of the Indicators windowOnce added to the "Configured" section, our user-defined inputs can be entered along with standard indicator properties.Once applied to a chart, the indicator should look something like the image below.ON THIS PAGE

---

## 56. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/set_up11

**Captured:** 2025-07-07T18:19:34.364Z

### Page Structure

- Set Up
  - Defining Input Parameters
      - ON THIS PAGE
- Set Up
  - Defining Input Parameters
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesBeginner - Simple MA Cross OverIntermediate - RSI with Stop Loss & Profit TargetSet UpEntering Strategy LogicCompilingThe Strategy Development ProcessWorking with AccountsHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXSet UpOur first tutorial covered using the Strategy Builder to create simple NinjaScript strategies or to build the framework needed for a more complex strategy.This tutorial will cover another approach, using the NinjaScript Editor and New Strategy Wizard.Within the NinjaTrader Control Center window select the New NinjaScript Editor... menu itemClick the "+" tab in the lower left, and select New Strategy to open a New Strategy WizardEnter the information as shown belowPress the "Next >" button until we are at the Inputs and Parameters pageDefining Input ParametersBelow you will define your strategy's input parameters. These are any input parameters that can be changed by the user when running or backtesting a strategy. If your strategy does not require any parameters leave the "Name" fields blank.Click the add button to create a User Input Parameter (See item 1 in the screenshot below)Fill out the Input Parameters window and click OK to create the input parameter (See item 2 in the screenshot below)Add the inputs as per the image belowPress the "Generate" button to generate the code in the NinjaScript Editor.You are now ready to continue to the Entering Strategy Logic page of this tutorial.ON THIS PAGEDefining Input ParametersSet UpOur first tutorial covered using the Strategy Builder to create simple NinjaScript strategies or to build the framework needed for a more complex strategy.This tutorial will cover another approach, using the NinjaScript Editor and New Strategy Wizard.Within the NinjaTrader Control Center window select the New NinjaScript Editor... menu itemClick the "+" tab in the lower left, and select New Strategy to open a New Strategy WizardEnter the information as shown belowPress the "Next >" button until we are at the Inputs and Parameters pageDefining Input ParametersBelow you will define your strategy's input parameters. These are any input parameters that can be changed by the user when running or backtesting a strategy. If your strategy does not require any parameters leave the "Name" fields blank.Click the add button to create a User Input Parameter (See item 1 in the screenshot below)Fill out the Input Parameters window and click OK to create the input parameter (See item 2 in the screenshot below)Add the inputs as per the image belowPress the "Generate" button to generate the code in the NinjaScript Editor.You are now ready to continue to the Entering Strategy Logic page of this tutorial.ON THIS PAGEDefining Input Parameters

---

## 57. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/entering_strategy_logic

**Captured:** 2025-07-07T18:19:38.350Z

### Page Structure

- Entering Strategy Logic
  - Using the OnStateChange() Method to Configure the Strategy
  - Using the OnBarUpdate() Method for the Core Strategy Logic
      - ON THIS PAGE
- Entering Strategy Logic
  - Using the OnStateChange() Method to Configure the Strategy
  - Using the OnBarUpdate() Method for the Core Strategy Logic
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesBeginner - Simple MA Cross OverIntermediate - RSI with Stop Loss & Profit TargetSet UpEntering Strategy LogicCompilingThe Strategy Development ProcessWorking with AccountsHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXEntering Strategy LogicUsing the OnStateChange() Method to Configure the StrategyThe OnStateChange() method is called once prior to running a strategy and can be used to set properties or call methods in preparation for running a strategy.Enter the code contained within the OnStateChange() method in the image below into the OnStateChange() method when we are in the State.DataLoaded state in the NinjaScript Editor.   {
     Description                               = @"RSI with a Stop Loss and Profit Target";
     Name                                     = "RSIwithStopAndTarget";
     Calculate                                 = Calculate.OnBarClose;
     EntriesPerDirection                       = 1;
     EntryHandling                             = EntryHandling.AllEntries;
     IsExitOnSessionCloseStrategy             = true;
     ExitOnSessionCloseSeconds                 = 30;
     IsFillLimitOnTouch                       = false;
     MaximumBarsLookBack                       = MaximumBarsLookBack.TwoHundredFiftySix;
     OrderFillResolution                       = OrderFillResolution.Standard;
     Slippage                                 = 0;
     StartBehavior                             = StartBehavior.WaitUntilFlat;
     TimeInForce                               = TimeInForce.Gtc;
     TraceOrders                               = false;
     RealtimeErrorHandling                     = RealtimeErrorHandling.StopCancelClose;
     StopTargetHandling                       = StopTargetHandling.PerEntryExecution;
     BarsRequiredToTrade                       = 20;
     // Disable this property for performance gains in Strategy Analyzer optimizations
     // See the Help Guide for additional information
     IsInstantiatedOnEachOptimizationIteration = true;
     RSIPeriod                                 = 14;
     RSISmooth                                 = 3;
     ProfitTarget                             = 12;
     StopLoss                                 = 6;
   }
   else if (State == State.DataLoaded)
   {
     AddChartIndicator(RSI(RSIPeriod, RSISmooth));

     SetStopLoss(CalculationMode.Ticks, StopLoss);
     SetProfitTarget(CalculationMode.Ticks, ProfitTarget);
   }
}
For more information on the strategy properties added in State.SetDefaults, please see our complete Strategy documentation.The AddChartIndicator() method is called and the RSI() indicator method is passed in which will automatically plot this indicator on a chart when the strategy runs.The method signature for the RSI() indicator is:RSI(int period, int smooth);
It is valid to have used the Add() method in the following manner:AddChartIndicator(RSI(14, 3));
However, instead of hard coding the period value to 14 and the smooth value to 3, we substituted the values for the user defined inputs we defined in the wizard. Calling the Add() method in the following manner:AddChartIndicator(RSI(RSIPeriod, RSISmooth));
Allows us to change the period and smooth parameters of the embedded RSI indicator in the strategy at run time. This gives us a higher level of flexibility when working with our strategy.SetStopLoss() and SetProfitTarget() are called with CalculationMode.Ticks. This means that when a position is opened, the strategy will immediately submit a stop and target order with a price that is calculated based on the StopLoss and ProfitTarget parameters passed in offset from the positions average entry price.Using the OnBarUpdate() Method for the Core Strategy LogicThe OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations. Therefore, this is the main method called for strat

[Content truncated...]


### Code Examples

#### Example 1

```csharp
{
     Description                               = @"RSI with a Stop Loss and Profit Target";
     Name                                     = "RSIwithStopAndTarget";
     Calculate                                 = Calculate.OnBarClose;
     EntriesPerDirection                       = 1;
     EntryHandling                             = EntryHandling.AllEntries;
     IsExitOnSessionCloseStrategy             = true;
     ExitOnSessionCloseSeconds                 = 30;
     IsFillLimitOnTouch                       = false;
     MaximumBarsLookBack                       = MaximumBarsLookBack.TwoHundredFiftySix;
     OrderFillResolution                       = OrderFillResolution.Standard;
     Slippage                                 = 0;
     StartBehavior                             = StartBehavior.WaitUntilFlat;
     TimeInForce                               = TimeInForce.Gtc;
     TraceOrders                               = false;
     RealtimeErrorHandling                     = RealtimeErrorHandling.StopCancelClose;
     StopTargetHandling                       = StopTargetHandling.PerEntryExecution;
     BarsRequiredToTrade                       = 20;
     // Disable this property for performance gains in Strategy Analyzer optimizations
     // See the Help Guide for additional information
     IsInstantiatedOnEachOptimizationIteration = true;
     RSIPeriod                                 = 14;
     RSISmooth                                 = 3;
     ProfitTarget                             = 12;
     StopLoss                                 = 6;
   }
   else if (State == State.DataLoaded)
   {
     AddChartIndicator(RSI(RSIPeriod, RSISmooth));

     SetStopLoss(CalculationMode.Ticks, StopLoss);
     SetProfitTarget(CalculationMode.Ticks, ProfitTarget);
   }
}
```

#### Example 2

```csharp
{
     Description                               = @"RSI with a Stop Loss and Profit Target";
     Name                                     = "RSIwithStopAndTarget";
     Calculate                                 = Calculate.OnBarClose;
     EntriesPerDirection                       = 1;
     EntryHandling                             = EntryHandling.AllEntries;
     IsExitOnSessionCloseStrategy             = true;
     ExitOnSessionCloseSeconds                 = 30;
     IsFillLimitOnTouch                       = false;
     MaximumBarsLookBack                       = MaximumBarsLookBack.TwoHundredFiftySix;
     OrderFillResolution                       = OrderFillResolution.Standard;
     Slippage                                 = 0;
     StartBehavior                             = StartBehavior.WaitUntilFlat;
     TimeInForce                               = TimeInForce.Gtc;
     TraceOrders                               = false;
     RealtimeErrorHandling                     = RealtimeErrorHandling.StopCancelClose;
     StopTargetHandling                       = StopTargetHandling.PerEntryExecution;
     BarsRequiredToTrade                       = 20;
     // Disable this property for performance gains in Strategy Analyzer optimizations
     // See the Help Guide for additional information
     IsInstantiatedOnEachOptimizationIteration = true;
     RSIPeriod                                 = 14;
     RSISmooth                                 = 3;
     ProfitTarget                             = 12;
     StopLoss                                 = 6;
   }
   else if (State == State.DataLoaded)
   {
     AddChartIndicator(RSI(RSIPeriod, RSISmooth));

     SetStopLoss(CalculationMode.Ticks, StopLoss);
     SetProfitTarget(CalculationMode.Ticks, ProfitTarget);
   }
}
```

#### Example 3

```csharp
RSI(int period, int smooth);
```

---

## 58. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/compiling8

**Captured:** 2025-07-07T18:19:42.351Z

### Page Structure

- Compiling
      - ON THIS PAGE
- Compiling
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesBeginner - Simple MA Cross OverIntermediate - RSI with Stop Loss & Profit TargetSet UpEntering Strategy LogicCompilingThe Strategy Development ProcessWorking with AccountsHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCompilingThe strategy code is now complete and needs to be compiled.If you completed this tutorial via the Strategy Wizard, simply follow the wizard instructions to the end, at which point the strategy will compile.If you self coded this tutorial, you can compile this strategy from within the NinjaScript Editor right click menu by selecting the Compile menu item, or by pressing the F5 key.It is important to understand that this process makes the strategy ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGECompilingThe strategy code is now complete and needs to be compiled.If you completed this tutorial via the Strategy Wizard, simply follow the wizard instructions to the end, at which point the strategy will compile.If you self coded this tutorial, you can compile this strategy from within the NinjaScript Editor right click menu by selecting the Compile menu item, or by pressing the F5 key.It is important to understand that this process makes the strategy ready for real-time use and will run natively within NinjaTrader directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the NinjaScript Editor.ON THIS PAGE

---

## 59. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/the_strategy_development_process

**Captured:** 2025-07-07T18:19:46.351Z

### Page Structure

- The Strategy Development Process
  - Describe your Strategy
  - Backtest and Optimize your Strategy
  - Real-Time Test your Strategy
  - Running on your Live Trading Account
      - ON THIS PAGE
- The Strategy Development Process
  - Describe your Strategy
  - Backtest and Optimize your Strategy
  - Real-Time Test your Strategy
  - Running on your Live Trading Account
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesBeginner - Simple MA Cross OverIntermediate - RSI with Stop Loss & Profit TargetSet UpEntering Strategy LogicCompilingThe Strategy Development ProcessWorking with AccountsHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXThe Strategy Development ProcessDescribe your StrategyDescribing your strategy means creating a set of objective rules that define the conditions used to enter and exit a market. Describing your strategy always starts with the wizard and then provides the following choices:Strategy Wizard with Condition Builder - This is a point and click approach for strategy description which is ideal for everyone from the non-programmer, novice programmer and advanced programmer.NinjaScript Editor - This is a modern scripting editor with full inline syntax checking and Intelliprompt. This is a great approach for those who want to manually code their strategy logic. If you are going to self code your strategy, please be familiar with the OnStateChange() and OnBarUpdate() methods.Backtest and Optimize your StrategyOnce you have completed describing your strategy you can then test it against historical data to objectively determine how the strategy performed on a specific market(s) in the past.Strategy Analyzer - You can backtest, optimize, and analyze your historical results.At this point in the process you will likely go through an iterative cycle by where you change your strategy description, backtest, change description and backtest until you have a strategy that meets your requirements.Real-Time Test your StrategyIt is critical that before you deploy your strategy against your live trading account, that you test it in real-time operation to ensure that the mechanics (operation) of your strategy behaves as you would expect it to. In addition, you can also forward test your strategy using real-time market data against the NinjaTrader trade simulation engine. NinjaTrader provides several options for real-time testing:Simulated Data Feed Connection - This is a random internally generated market with user controlled trend and is great for force testing operation of a strategy.Playback Connection - Record, replay at user defined speeds multiple markets simultaneously and run your strategies.Real-time Simulation - Connect to your broker or market data vendor in real-time and run your strategies through our state of the art simulation engine.You can run your strategy from either a chart or the Strategies tab of the Control Center window. You can generate real-time strategy performance data from the Strategies tab.Running on your Live Trading AccountNow that you have described, backtested and real-time tested your strategy, you are ready to automate your strategy against your live trading account. A few tips you should know:Please make sure you fully understand the live run-time options.Live strategy performance will vary from your backtested results.Please make sure you fully understand Strategy Position vs Account Position... your strategy position is not a one-to-one relationship with your brokerage account position... you may need to synchronize if they are not synchronized.Strategies are automatically terminated (stop running) on NinjaTrader shut down.Automated trading does not mean go fishing while your computer trades for you. We highly recommend that you are within close proximity to your computer while it is running an automated trading strategy; you never know what can go wrong.You can run multiple trading strategies at the same time in the same market.ON THIS PAGEDescribe your StrategyBacktest and Optimize your StrategyReal-Time Test your StrategyRunning on your Live Trading AccountThe Strategy Development ProcessDescribe your StrategyDescribing your strategy means creating a set of objective rules that define the conditions used to enter and exit a market. Describing your strategy always starts with the wizard and then provi

[Content truncated...]


---

## 60. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/working_with_accounts

**Captured:** 2025-07-07T18:19:51.361Z

### Page Structure

- Working with Accounts
      - ON THIS PAGE
- Working with Accounts
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesBeginner - Simple MA Cross OverIntermediate - RSI with Stop Loss & Profit TargetSet UpEntering Strategy LogicCompilingThe Strategy Development ProcessWorking with AccountsHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXWorking with AccountsThere are a couple of fundamental concepts that should be understood in terms of how NinjaScript strategies behave in a live-trading environment. More information can be found on the Strategy Position vs Account Position, and Syncing Account Positions pages.ON THIS PAGEWorking with AccountsThere are a couple of fundamental concepts that should be understood in terms of how NinjaScript strategies behave in a live-trading environment. More information can be found on the Strategy Position vs Account Position, and Syncing Account Positions pages.ON THIS PAGE

---

## 61. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/historical_order_backfill_logic

**Captured:** 2025-07-07T18:20:00.359Z

### Page Structure

- Historical Order Backfill Logic
  - Understanding How Orders are backfilled for NinjaScript strategies
  - General Outline
  - Step 1 - Prepare to Calculate Fill Prices
  - Step 2 - Take Three Passes To Determine Fill Price
  - Note
    - 1. First Pass
    - 2. Second Pass
    - 3. Third Pass
  - Step 3 - Fill the Order
      - ON THIS PAGE
- Historical Order Backfill Logic
  - Understanding How Orders are backfilled for NinjaScript strategies
  - General Outline
  - Step 1 - Prepare to Calculate Fill Prices
  - Step 2 - Take Three Passes To Determine Fill Price
  - Note
    - 1. First Pass
    - 2. Second Pass
    - 3. Third Pass
  - Step 3 - Fill the Order
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXHistorical Order Backfill LogicUnderstanding How Orders are backfilled for NinjaScript strategiesNinjaScript strategies use an algorithm to process order fills on historical data in two scenarios: when processing fills in the Strategy Analyzer, or when processing historical orders for a live running strategy. The algorithm fills historical orders using the same set of logic in both scenarios. Below is an outline of the logic used to determine the appropriate fill price for each historical order. When more than one order needs to be filled at once, the logic below will be ran for each individual order in succession.General OutlineThe steps involved in determining the appropriate fill price for an order are documented in their own sections below. The general, top-level outline of the logic can be broken into three steps:Prepare to calculate fill pricesTake three passes to calculate the appropriate fill price for each order which needs filledFill the orders using the calculated fill priceStep 1 - Prepare to Calculate Fill PricesDetermine all orders that need filledDetermine the current bar being formed at the timeDetermine whether the current bar's first move was upward or downwardDetermine the strategy being runDetermine the Bars In Progress the strategy is currently processingStep 2 - Take Three Passes To Determine Fill PriceThe bulk of the backfill logic takes place in this step. Here orders are tested for their order types and prices, and are compared against current bar data to determine the appropriate fill prices per order type in different scenarios.NoteThroughout these three passes, prices are temporarily stored in two variables: a "next high price" and a "next low price." These are used to approximate the price that would be hit on the next tick, for the purpose of setting the fill price.1. First Passa. If the current bar moved up first, save the current bar high price as the "next high price," then save the current bar Open price as the "next low price."i. If it moved down first, save the current bar Open price as the "next high price," then save the current bar Low price as the "next low price."b. If it's a Market Buy order, set the fill price to the lesser of the "next high price" or the bar Open.i. If it's a Market Sell order, set the fill price to the greater of the "next high price" or the bar Open.c. Ensure the strategy is currently processing the bar series on which the order resides, then:i. If the current order is Long, set the fill price to the lesser of the "next high price" or the current bar Open, taking slippage into account.If it is Short, set the fill price to the greater of the saved "next low price" or the current bar Open, taking slippage into account.d. Handle the special case of Limit orders with "Fill Limit Orders on Touch" enabled.i. If the limit price has been touched, set the fill price to current bar Open.e. Ensure the order would be filled without errors by comparing its stop and/or limit prices against each other and the current bar, then:i. For Limit orders, set the fill price to the current order's Limit price (however this is 'clamped' to happen inside the bar though).ii. For Stop Limit orders:If the order is Long, set the fill price to the greater of the existing fill price value or the current order's Limit price.If it is Short, set the fill price to the lesser of the existing fill price value or the current order's Limit price.2. Second Passa. If the current bar moved up first, save the current bar High price as the "next high price," then save the current bar Low price as the "next low price."i. If it moved down first, save the current bar Low price as the "next high price," then save the current bar Low price as the "next low price."b. If it's a Market Buy order and the bar moved up first, set the fill price to the lesser of the "next high 

[Content truncated...]


---

## 62. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/multi_threading_consideration_for_ninjascript

**Captured:** 2025-07-07T18:20:05.348Z

### Page Structure

- Multi-Threading Consideration for NinjaScript
  - Multi-Threading Overview
  - Using A Dispatcher
  - Note
  - Thread Access
  - Cross Thread Exceptions
  - Access Violation Exception
  - Multi-threaded consideration for Order, Execution and Position objects
      - ON THIS PAGE
- Multi-Threading Consideration for NinjaScript
  - Multi-Threading Overview
  - Using A Dispatcher
  - Note
  - Thread Access
  - Cross Thread Exceptions
  - Access Violation Exception
  - Multi-threaded consideration for Order, Execution and Position objects
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXMulti-Threading Consideration for NinjaScriptMulti-Threading OverviewWith the introduction of multi-threading in NinjaTrader special considerations should be made when programming your NinjaScript objects. Multi-threading basically allows NinjaTrader to take advantage of multi-core CPUs commonplace in modern computing to do multiple tasks at the same time. While this has many advantages for multi-tasking, it can cause new types of issues you may have not needed to consider before. This page was designed to serve as a high-level overview of some of the most common scenarios that can arise due to multi-threading, but should not be considered an exhaustive list.Using A DispatcherDepending on your CPU configuration, the NinjaTrader application will usually consist of multiple main UI threads, where various features like Charts or NinjaScript objects run, along with a number of background worker threads where events such as market data updates will be distributed throughout the product. In principle, an object can only access information related to objects that exist on the same thread. It is possible (and quite likely), that the thread which a NinjaScript object is running will not be the same thread as the event which is calling the object. In cases where you need to access objects on the UI from a NinjaScript objects calling event thread, a dispatcher can be used.NoteAs a best practice, you should always make sure to use Dispatcher.InvokeAsync() to ensure your action is done asynchronously to any internal NinjaTrader actions. Calling the synchronous Dispatcher.Invoke() method can potentially result in a deadlock scenarios as your script is loaded.
if (State == State.Historical)
{
   if (ChartControl != null)
   {
     // add some text to the UserControlCollection through the ChartControls dispatcher
     ChartControl.Dispatcher.InvokeAsync(new Action(() => {
         UserControlCollection.Add(new System.Windows.Controls.TextBlock {
           Text = "\nAdded by the ChartControl Dispatcher."
         });
     }));
   }
}
Thread AccessSince market data is distributed across the entire application by a randomly assigned UI thread, there is no guarantee that your object will be running on the same event thread that is calling the object. Therefore it is recommend that you call Dispatcher.CheckAccess() in order to test if you truly need to dispatch the requested action.
// check if the current object is already on the calling thread
if (Dispatcher.CheckAccess())
{
   // execute action directly
   action(args);
}
// otherwise run the action from the thread that created the object
else
{
   // dispatch action to calling thread
   Dispatcher.InvokeAsync(action, args);
}
Cross Thread ExceptionsWhen accessing objects included on the UI, you may receive the following error if you attempt to access a certain property/method from the wrong thread:"Error on calling 'OnBarUpdate' method on bar 0: You are accessing an object which resides on another thread. I.E. creating your own Brush without calling .Freeze(), or trying to access a UI control from the wrong thread without using a Dispatcher"This error can be avoided by invoking the Dispatcher used on the appropriate UI thread.Access Violation ExceptionShould you be using custom resources like text files, static members, etc. it is important to protect your resources from concurrent access. If NinjaTrader tried to use the resource at the same time you would run into errors similar to this one:8/20/2010 12:14:29 PM|3|128|Error on calling 'OnBarUpdate' method for strategy 'SampleStrategy/1740b50bfe5d4bd896b0533725622400': The process cannot access the file 'c:\sample.txt' because it is being used by another process.
private object lockObj = new object();

private void WriteFile()
{
   // lock a generic object to ensure only one thread is accessing the 

[Content truncated...]


### Code Examples

#### Example 1

```csharp
if (State == State.Historical)
{
   if (ChartControl != null)
   {
     // add some text to the UserControlCollection through the ChartControls dispatcher
     ChartControl.Dispatcher.InvokeAsync(new Action(() => {
         UserControlCollection.Add(new System.Windows.Controls.TextBlock {
           Text = "\nAdded by the ChartControl Dispatcher."
         });
     }));
   }
}
```

#### Example 2

```csharp
if (State == State.Historical)
{
   if (ChartControl != null)
   {
     // add some text to the UserControlCollection through the ChartControls dispatcher
     ChartControl.Dispatcher.InvokeAsync(new Action(() => {
         UserControlCollection.Add(new System.Windows.Controls.TextBlock {
           Text = "\nAdded by the ChartControl Dispatcher."
         });
     }));
   }
}
```

#### Example 3

```csharp
// check if the current object is already on the calling thread
if (Dispatcher.CheckAccess())
{
   // execute action directly
   action(args);
}
// otherwise run the action from the thread that created the object
else
{
   // dispatch action to calling thread
   Dispatcher.InvokeAsync(action, args);
}
```

---

## 63. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/multi_time_frame_instruments

**Captured:** 2025-07-07T18:20:10.402Z

### Page Structure

- Multi-Time Frame & Instruments
  - Multi-Series Scripting Overview
  - Note
  - Note
  - Data processing sequence
  - Note
  - Shared Timestamps
  - Note
  - Adding Additional Bars Objects to NinjaScript
  - Warning
  - Note
  - Note
    - Initializing a Series<t> with BarsArray
    - Initializing a Series<t> with an Indicator Method
  - How Bars Data is Referenced
    - Special considerations for session boundaries
  - Using Bars Objects as Input to Indicator Methods
  - Note
  - True Event Driven OnBarUpdate() Method
  - Note
  - Accessing the Price Data in a Multi-Bars NinjaScript
  - Entering, Exiting and Retrieving Position Information
  - Note
      - ON THIS PAGE
- Multi-Time Frame & Instruments
  - Multi-Series Scripting Overview
  - Note
  - Note
  - Data processing sequence
  - Note
  - Shared Timestamps
  - Note
  - Adding Additional Bars Objects to NinjaScript
  - Warning
  - Note
  - Note
    - Initializing a Series<t> with BarsArray
    - Initializing a Series<t> with an Indicator Method
  - How Bars Data is Referenced
    - Special considerations for session boundaries
  - Using Bars Objects as Input to Indicator Methods
  - Note
  - True Event Driven OnBarUpdate() Method
  - Note
  - Accessing the Price Data in a Multi-Bars NinjaScript
  - Entering, Exiting and Retrieving Position Information
  - Note
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXMulti-Time Frame & InstrumentsMulti-Series Scripting OverviewNinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.NoteIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy (even if the instrument is the same). The market data subscription behavior occurs both in real-time and during TickReplay historical.It is also important that you understand the following method and properties:AddDataSeries()BarsArrayBarsInProgressCurrentBarsNoteAs we move through this section, the term "Primary Bars" will be used and for the purpose of clarification, this will always refer to the first Bars object loaded into a script. For example, if you apply a script on MSFT 1 minute chart, the primary Bars would be MSFT 1 minute data set.This section is written in sequential fashion. Example code is re-used and built upon from sub section to sub section.Data processing sequenceUnderstanding the sequence in which bars series process and the granularity provided by market data vendors is essential for efficient multi-series development. Let’s assume we have two series (primary and secondary) in our script, which is representing the same instrument, yet different intervals. During historical data processing, NinjaTrader updates the two series strictly according to their timestamps, calling the primary bar series of the corresponding timestamps first, and then calling the secondary series.NoteHistorical bars are processed according to their timestamps with the primary bars first, followed by the secondary, which is NOT guaranteed to be the same sequence that these events occurred in real-time. If your development requires ticks to process in the same sequence historically as well as in real-time, you will need to enable Tick Replay (utilizes more PC resources).Shared TimestampsIn circumstances where multiple bars share the same exact timestamps, your primary bars series will always be processed first, followed by the secondary bars series (regardless of the period value used). Consequently, if you were looking to obtain a value from the secondary bars series, it would ONLY be available after the primary series has been processed for the same timestamps. For example, consider a news event or a fast moving market with an influx of ticks (session begin/session end). This activity will yield a wider range of bars than usual and the probability of those bars sharing the same timestamps increases. If such a succession of bars with the same timestamps is processed, the primary bars would be processed first and then the secondary bars during this period.NoteTip: While the following behavior applies to all period types, the effects are amplified on smaller time frames. If you plan on using a high-resolution (e.g., 1-second, 10-tick, etc), please make sure to thoroughly read and understand the material below when working with these additional serie

[Content truncated...]


### Code Examples

#### Example 1

```csharp
protected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {                
        Name   = "Multi-Time Frame & Instruments Example";
    }
    else if (State == State.Configure)
    {   
        AddDataSeries(BarsPeriodType.Minute, 3);
        AddDataSeries("AAPL", BarsPeriodType.Minute, 1);
    }
}
```

#### Example 2

```csharp
protected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {                
        Name   = "Multi-Time Frame & Instruments Example";
    }
    else if (State == State.Configure)
    {   
        AddDataSeries(BarsPeriodType.Minute, 3);
        AddDataSeries("AAPL", BarsPeriodType.Minute, 1);
    }
}
```

#### Example 3

```csharp
private Series<`double`> myEmptyIndexedSeries; // Define a Series<`t`> object variable.

// Initialize the Series object to have the same number of index slots as BarsArray[1]
protected override void OnStateChange()
{
    if (State == State.DataLoaded)
    {
        // Passing in BarsArray[1] as an argument results in an empty Series with an identical number of index slots
        myEmptyIndexedSeries = new Series<double>(BarsArray[1]);
    }
}
```

---

## 64. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/understanding_the_lifecycle_of

**Captured:** 2025-07-07T18:20:15.348Z

### Page Structure

- NinjaScript Lifecycle
  - When NinjaTrader instantiates a NinjaScript object
  - Note
  - Note
  - What does this mean for me?
  - Example
  - Cloning NinjaScript
  - Note
  - Saving NinjaScript Properties to the Workspace via XML Serialization
      - ON THIS PAGE
- NinjaScript Lifecycle
  - When NinjaTrader instantiates a NinjaScript object
  - Note
  - Note
  - What does this mean for me?
  - Example
  - Cloning NinjaScript
  - Note
  - Saving NinjaScript Properties to the Workspace via XML Serialization
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXNinjaScript LifecycleNinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.When NinjaTrader instantiates a NinjaScript objectThere are two categories of instances instantiated by NinjaTrader:"UI" instances representing its default properties on various user interfacesThe "configured" instance executing your custom instructionsIn both categories, OnStateChange() is called at least twice:  once to State.SetDefaultsacquiring various default property values, and then again to State.Terminated handling internal references cleanup.NoteIt is important to understand that previous major versions of NinjaTrader were not so diligent in running termination logic for UI instances and the current major NinjaTrader 8 version has been changed to help properly address related issues.To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:User right clicks on a Chart and select "Indicator"User adds an Indicator from the Available listUser configures desired Properties and presses "Apply" or "OK"During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:The instance displaying the Name property to the list of "Available" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)The instance displaying the individual Name and its default PropertiesThe instance configured and executing on the chartTo visualize how each instance goes through its States, please consider the logic and flow chart below:In order to display the indicator name in the list of "Available" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the "Properties" grid.  This only occurs for the individual indicator.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.It is the 3rd "configured" instance you are concerned with developing, but you should also be aware of the "UI" instances which are triggered at various stages of NinjaTrader.NoteNotes:The example above is written for an indicator, but the same concept of state management applies to every NinjaScript object typeThe UI instances do not reach State.Terminated until the user closes out of the UI feature displaying the objectSince AddOns run in the background and are not dependent on UI elements, they will run through their SetDefaults/Terminated states after each NinjaScript compile and startup/shutdown of NinjaTrader.The configured instance will also be cloned back to UI instances during various user actions (e.g, re-opening an indicator dialog to reconfigure settings, or user copying & pasting the indicator to a new panel or chart).  Therefore you should not assume that objects (such as ChartControl) will not be accessible in the UI instances.In some extreme scenarios, you may need to execute custom logic before or after an object is cloned.  Overriding the default behavior can be done via the virtual Clone() methodWhat does this mean for me?Since OnStateChange() can be called at various times throughout Ninj

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// custom flag to help time termination logic
private bool toolBarNeedsReset = false;

protected override void OnStateChange()
{
  if (State == State.SetDefaults)
  {
    Name = "State lifetime indicator";
  }
  else if (State == State.Historical)
  {
    // before indicator starts historical processing
    // add a custom tool bar using a custom method
    AddToolBarButton(); // this is a pseudo-method for example purposes
    toolBarNeedsReset = true; // use a flag to track this logic was executed
  }

  else if (State == State.Terminated)
  {
    // here we intend to remove the custom tool bar when the indicator shuts down
    if (toolBarNeedsReset) // flag is only true after actually added
        RemoveToolBarButton();
  }
}
```

#### Example 2

```csharp
// custom flag to help time termination logic
private bool toolBarNeedsReset = false;

protected override void OnStateChange()
{
  if (State == State.SetDefaults)
  {
    Name = "State lifetime indicator";
  }
  else if (State == State.Historical)
  {
    // before indicator starts historical processing
    // add a custom tool bar using a custom method
    AddToolBarButton(); // this is a pseudo-method for example purposes
    toolBarNeedsReset = true; // use a flag to track this logic was executed
  }

  else if (State == State.Terminated)
  {
    // here we intend to remove the custom tool bar when the indicator shuts down
    if (toolBarNeedsReset) // flag is only true after actually added
        RemoveToolBarButton();
  }
}
```

#### Example 3

```csharp
// custom flag to help time termination logic
private bool toolBarNeedsReset = false;

protected override void OnStateChange()
{
  if (State == State.SetDefaults)
  {
    Name = "State lifetime indicator";
  }
  else if (State == State.Historical)
  {
    // before indicator starts historical processing
    // add a custom tool bar using a custom method
    AddToolBarButton(); // this is a pseudo-method for example purposes
    toolBarNeedsReset = true; // use a flag to track this logic was executed
  }

  else if (State == State.Terminated)
  {
    // here we intend to remove the custom tool bar when the indicator shuts down
    if (toolBarNeedsReset) // flag is only true after actually added
        RemoveToolBarButton();
  }
}
```

---

## 65. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_3rd_party_indicators

**Captured:** 2025-07-07T18:20:20.354Z

### Page Structure

- Using 3rd Party Indicators
  - 3rd Party Indicators Overview
  - Note
  - Vendor File
  - Adding a Reference
  - Warning
      - ON THIS PAGE
- Using 3rd Party Indicators
  - 3rd Party Indicators Overview
  - Note
  - Vendor File
  - Adding a Reference
  - Warning
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing 3rd Party Indicators3rd Party Indicators OverviewYou can use 3rd party indicators within your strategies or custom indicators. A 3rd party indicator is an indicator that was not developed by NinjaTrader.NoteIt is important to understand the functionality provided or NOT provided in a 3rd party proprietary indicator. Just because they provide an indicator that displays a bullish or bearish trend on a chart does NOT mean that you can access this trend state from their indicator.   It is up to the developer of the indicator to determine what information is accessible.3rd party indicators can be provided to you in one of the following ways:NinjaScript archive file that can be directly imported into NinjaTraderA custom installerA set of files and instructions for saving them in the correct foldersIf you were provided with a NinjaScript archive file that you have successfully imported via the Control Center window "File > Utilities > Import NinjaScript" menu, you can skip over the information below since NinjaTrader automatically configures the indicators ready for use.If you were provided with a custom installer or a compiled assembly (.DLL) file that you had to manually save in the folder My Documents\NinjaTrader Folder>\bin\Custom then you must follow the instructions below.Vendor FileThe 3rd party developer should have either installed a "Vendor" file or provided you with one. Its likely in the format "NinjaTrader.VendorName.cs" where VendorName is the name of the 3rd party vendor. This file allows you to conveniently access their indicators.If you were provided an installer, you can check with the vendor if this file was included or;If they provided you this file, save it to "My Documents<NinjaTrader Folder>\bin\Custom" and restart NinjaTraderAdding a ReferenceFrom within the NinjaScript Editor, right click on your mouse to bring up the context menu and select the sub-menu References... as per the image to the right.A References window will appearPress the "add" and select the 3rd party vendor DLL fileWarningPlease make sure in this step to select only the 'true' DLL file needed for reference, which would not contain any X86 or X64 suffixes in its file-name, otherwise you could run into compile issues later.You will see a reference to the 3rd party vendor DLL in the References windowPress the OK buttonYou will now be able to access the indicator methods provided by the 3rd party vendorON THIS PAGE3rd Party Indicators OverviewVendor FileAdding a ReferenceUsing 3rd Party Indicators3rd Party Indicators OverviewYou can use 3rd party indicators within your strategies or custom indicators. A 3rd party indicator is an indicator that was not developed by NinjaTrader.NoteIt is important to understand the functionality provided or NOT provided in a 3rd party proprietary indicator. Just because they provide an indicator that displays a bullish or bearish trend on a chart does NOT mean that you can access this trend state from their indicator.   It is up to the developer of the indicator to determine what information is accessible.3rd party indicators can be provided to you in one of the following ways:NinjaScript archive file that can be directly imported into NinjaTraderA custom installerA set of files and instructions for saving them in the correct foldersIf you were provided with a NinjaScript archive file that you have successfully imported via the Control Center window "File > Utilities > Import NinjaScript" menu, you can skip over the information below since NinjaTrader automatically configures the indicators ready for use.If you were provided with a custom installer or a compiled assembly (.DLL) file that you had to manually save in the folder My Documents\NinjaTrader Folder>\bin\Custom then you must follow the instructions below.Vendor FileThe 3rd party developer should have either

[Content truncated...]


---

## 66. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_atm_strategies

**Captured:** 2025-07-07T18:20:24.362Z

### Page Structure

- Using ATM Strategies
  - There is a Clear Line
      - ON THIS PAGE
- Using ATM Strategies
  - There is a Clear Line
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing ATM StrategiesYou can create an automated strategy that generates a trade signal that executes a NinjaTrader ATM Strategy.ATM Strategies operate in real-time only and will not execute on historical data thus they can't be backtestedExecutions resulting from an ATM Strategy that is created from within a NinjaScript automated strategy will not plot on a chart during real-time operationStrategy set up parameters such as EntriesPerDirection, EntryHandling, IsExitOnSessionCloseStrategy do not apply when calling the AtmStrategyCreate() methodExecutions from ATM Strategies will not have an impact on the hosting NinjaScript strategy position and PnL - the NinjaScript strategy hands off the execution aspects to the ATM, thus no monitoring via the regular NinjaScript strategy methods will take place (also applies to strategy performance tracking)ATM Strategy stop orders can either be StopMarket or StopLimit orders, depending on which type is defined in the ATM Strategy Template (Advanced Options) you call in the AtmStrategyCreate() method in your NinjaScript strategy. To make the distinction clear which is used, following a naming convention for the template name is highly suggested (i.e. AtmStrategyTemplate_STPLMT)A general sample for calling ATM's is preinstalled with NinjaTrader under the 'SampleATMStrategy' script - for a script showing how to implement reversal type setups, please see this link to our online resources.There is a Clear LineThere is a clear line between a NinjaScript Strategy and an ATM Strategy. The use model for creating an ATM Strategy within a NinjaScript Strategy is when you want to programmatically monitor and generate an entry signal and then manualy manage the resulting open position via an ATM Strategy in one of NinjaTrader's order entry windows.ON THIS PAGEThere is a Clear LineUsing ATM StrategiesYou can create an automated strategy that generates a trade signal that executes a NinjaTrader ATM Strategy.ATM Strategies operate in real-time only and will not execute on historical data thus they can't be backtestedExecutions resulting from an ATM Strategy that is created from within a NinjaScript automated strategy will not plot on a chart during real-time operationStrategy set up parameters such as EntriesPerDirection, EntryHandling, IsExitOnSessionCloseStrategy do not apply when calling the AtmStrategyCreate() methodExecutions from ATM Strategies will not have an impact on the hosting NinjaScript strategy position and PnL - the NinjaScript strategy hands off the execution aspects to the ATM, thus no monitoring via the regular NinjaScript strategy methods will take place (also applies to strategy performance tracking)ATM Strategy stop orders can either be StopMarket or StopLimit orders, depending on which type is defined in the ATM Strategy Template (Advanced Options) you call in the AtmStrategyCreate() method in your NinjaScript strategy. To make the distinction clear which is used, following a naming convention for the template name is highly suggested (i.e. AtmStrategyTemplate_STPLMT)A general sample for calling ATM's is preinstalled with NinjaTrader under the 'SampleATMStrategy' script - for a script showing how to implement reversal type setups, please see this link to our online resources.There is a Clear LineThere is a clear line between a NinjaScript Strategy and an ATM Strategy. The use model for creating an ATM Strategy within a NinjaScript Strategy is when you want to programmatically monitor and generate an entry signal and then manualy manage the resulting open position via an ATM Strategy in one of NinjaTrader's order entry windows.ON THIS PAGEThere is a Clear Line

---

## 67. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_bitmapimage_objects_with_buttons

**Captured:** 2025-07-07T18:20:29.365Z

### Page Structure

- Using BitmapImage objects with Buttons
  - Images as Buttons Overview
  - Note
  - Adding a Button to a Chart Toolbar Using an Image as the Background
      - ON THIS PAGE
- Using BitmapImage objects with Buttons
  - Images as Buttons Overview
  - Note
  - Adding a Button to a Chart Toolbar Using an Image as the Background
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing BitmapImage objects with ButtonsImages as Buttons OverviewBitmapImage objects can be used to apply an image as a background to a Button object added to a NinjaTrader window.NoteThe following topic covers methods and properties outside of the NinjaScript libraries. Most of the items covered in the example below belong to .NET's System.Windows.Media.Imaging and System.Windows.Controls namespaces. More information on these namespaces can be found at the links below:System.Windows.ControlsSystem.Windows.Media.ImagingUsing an image as the background for a button can be achieved through a fairly straightforward process using some of the .NET framework's Controls and Imaging methodsThere are a few best practices to keep in mind when working with Buttons:Dispose of any leftover objects in State.Terminated for efficient memory useUse your object's main Dispatcher when adding or removing Buttons to or from your chart, to ensure that the correct thread is usedBe aware of the proper States in which to initialize objects related to the Button (State.Configure), apply the Button (State.Historical), and dispose of unneeded objects (State.Terminated)Adding a Button to a Chart Toolbar Using an Image as the BackgroundThe example below walks through the process of adding a Button to a chart toolbar specifically, and applying a .jpg image as the Button's background. This example also displays several best practices when working with Buttons, such as proper object disposal and ensuring that the Button is not populated when the indicator is applied in an inactive chart tab.//Add the following Using statements
using System.Windows.Media.Imaging;
using System.Windows.Controls;

public class addButton : Indicator
{
  // Define a Chart object to refer to the chart on which the indicator resides
  private Chart chartWindow;

  // Define a Button
  private System.Windows.Controls.Button myButton = null;

  // Instantiate a BitmapImage to hold an image
  BitmapImage myBitmapImage = new BitmapImage();

  // Instantiate an ImageBrush to apply to the Button
  ImageBrush backgroundImage = new ImageBrush();

  private bool IsToolBarButtonAdded;

  protected override void OnStateChange()
  {
      if (State == State.Configure)
      {
          // Assign an image on the filesystem to the BitmapImage.

           // This example assumes that a jpg image named "ButtonBackground" resides in the install directory
          myBitmapImage.BeginInit();
          myBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "ButtonBackground.jpg");
          myBitmapImage.EndInit();
 
          // Assign the BitmapImage as the ImageSource of the ImageBrush
          backgroundImage.ImageSource = myBitmapImage;
      }
      else if (State == State.Historical)
      {
          //Call the custom addButtonToToolbar method in State.Historical to ensure it is only done when applied to a chart

           // -- not when loaded in the Indicators window
          if (!IsToolBarButtonAdded) AddButtonToToolbar();
      }
      else if (State == State.Terminated)
      {
          //Call a custom method to dispose of any leftover objects in State.Terminated
          DisposeCleanUp();
      }
  }

  private void AddButtonToToolbar()
  {
      // Use this.Dispatcher to ensure code is executed on the proper thread
      ChartControl.Dispatcher.InvokeAsync((Action)(() =>
      {

          //Obtain the Chart on which the indicator is configured
          chartWindow = Window.GetWindow(this.ChartControl.Parent) as Chart;
          if (chartWindow == null)
          {
              Print("chartWindow == null");
              return;
          }
 
          // Create a style to apply to the button
          Style s = new Style();
          s.TargetType = typeof(System.Windows.Controls.Button);
          s.Setters.Add(new Sett

[Content truncated...]


### Code Examples

#### Example 1

```csharp
//Add the following Using statements
using System.Windows.Media.Imaging;
using System.Windows.Controls;

public class addButton : Indicator
{
  // Define a Chart object to refer to the chart on which the indicator resides
  private Chart chartWindow;

  // Define a Button
  private System.Windows.Controls.Button myButton = null;

  // Instantiate a BitmapImage to hold an image
  BitmapImage myBitmapImage = new BitmapImage();

  // Instantiate an ImageBrush to apply to the Button
  ImageBrush backgroundImage = new ImageBrush();

  private bool IsToolBarButtonAdded;

  protected override void OnStateChange()
  {
      if (State == State.Configure)
      {
          // Assign an image on the filesystem to the BitmapImage.

           // This example assumes that a jpg image named "ButtonBackground" resides in the install directory
          myBitmapImage.BeginInit();
          myBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "ButtonBackground.jpg");
          myBitmapImage.EndInit();
 
          // Assign the BitmapImage as the ImageSource of the ImageBrush
          backgroundImage.ImageSource = myBitmapImage;
      }
      else if (State == State.Historical)
      {
          //Call the custom addButtonToToolbar method in State.Historical to ensure it is only done when applied to a chart

           // -- not when loaded in the Indicators window
          if (!IsToolBarButtonAdded) AddButtonToToolbar();
      }
      else if (State == State.Terminated)
      {
          //Call a custom method to dispose of any leftover objects in State.Terminated
          DisposeCleanUp();
      }
  }

  private void AddButtonToToolbar()
  {
      // Use this.Dispatcher to ensure code is executed on the proper thread
      ChartControl.Dispatcher.InvokeAsync((Action)(() =>
      {

          //Obtain the Chart on which the indicator is configured
          chartWindow = Window.GetWindow(this.ChartControl.Parent) as Chart;
          if (chartWindow == null)
          {
              Print("chartWindow == null");
              return;
          }
 
          // Create a style to apply to the button
          Style s = new Style();
          s.TargetType = typeof(System.Windows.Controls.Button);
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontSizeProperty, 11.0));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.BackgroundProperty, Brushes.Orange));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.ForegroundProperty, Brushes.Black));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontFamilyProperty, new FontFamily("Arial")));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontWeightProperty, FontWeights.Bold));
 
          // Instantiate the Button
          myButton = new System.Windows.Controls.Button();
 
          //Set Button Style            
          myButton.Style = s;
 
          // Set the Imagebrush as the Background for the Button
          myButton.Background = backgroundImage;
 
          myButton.Content = "Click Here";
          myButton.IsEnabled = true;
          myButton.HorizontalAlignment = HorizontalAlignment.Left;
 
          // Add the Button to the Chart's Toolbar
          chartWindow.MainMenu.Add(myButton);
 
          //Prevent the Button From Displaying when WorkSpace Opens if it is not in an active tab
          myButton.Visibility = Visibility.Collapsed;
          foreach (TabItem tab in this.chartWindow.MainTabControl.Items)
          {
              if ((tab.Content as ChartTab).ChartControl == this.ChartControl

                   && tab == this.chartWindow.MainTabControl.SelectedItem)
              {
                  myButton.Visibility = Visibility.Visible;
              }
          }
          IsToolBarButtonAdded = true;
      }));
  }

  private void DisposeCleanUp()
  {
      //ChartWindow Null Check
      if (chartWindow != null)
      {
          //Dispatcher used to Assure Executed on UI Thread
          ChartControl.Dispatcher.InvokeAsync((Action)(() =>
          {
              //Button Null Check
              if (myButton != null)
              {
                  //Remove Button from Indicator's Chart ToolBar
                  chartWindow.MainMenu.Remove(myButton);
              }
          }));
      }
  }
}
```

#### Example 2

```csharp
//Add the following Using statements
using System.Windows.Media.Imaging;
using System.Windows.Controls;

public class addButton : Indicator
{
  // Define a Chart object to refer to the chart on which the indicator resides
  private Chart chartWindow;

  // Define a Button
  private System.Windows.Controls.Button myButton = null;

  // Instantiate a BitmapImage to hold an image
  BitmapImage myBitmapImage = new BitmapImage();

  // Instantiate an ImageBrush to apply to the Button
  ImageBrush backgroundImage = new ImageBrush();

  private bool IsToolBarButtonAdded;

  protected override void OnStateChange()
  {
      if (State == State.Configure)
      {
          // Assign an image on the filesystem to the BitmapImage.

           // This example assumes that a jpg image named "ButtonBackground" resides in the install directory
          myBitmapImage.BeginInit();
          myBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "ButtonBackground.jpg");
          myBitmapImage.EndInit();
 
          // Assign the BitmapImage as the ImageSource of the ImageBrush
          backgroundImage.ImageSource = myBitmapImage;
      }
      else if (State == State.Historical)
      {
          //Call the custom addButtonToToolbar method in State.Historical to ensure it is only done when applied to a chart

           // -- not when loaded in the Indicators window
          if (!IsToolBarButtonAdded) AddButtonToToolbar();
      }
      else if (State == State.Terminated)
      {
          //Call a custom method to dispose of any leftover objects in State.Terminated
          DisposeCleanUp();
      }
  }

  private void AddButtonToToolbar()
  {
      // Use this.Dispatcher to ensure code is executed on the proper thread
      ChartControl.Dispatcher.InvokeAsync((Action)(() =>
      {

          //Obtain the Chart on which the indicator is configured
          chartWindow = Window.GetWindow(this.ChartControl.Parent) as Chart;
          if (chartWindow == null)
          {
              Print("chartWindow == null");
              return;
          }
 
          // Create a style to apply to the button
          Style s = new Style();
          s.TargetType = typeof(System.Windows.Controls.Button);
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontSizeProperty, 11.0));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.BackgroundProperty, Brushes.Orange));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.ForegroundProperty, Brushes.Black));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontFamilyProperty, new FontFamily("Arial")));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontWeightProperty, FontWeights.Bold));
 
          // Instantiate the Button
          myButton = new System.Windows.Controls.Button();
 
          //Set Button Style            
          myButton.Style = s;
 
          // Set the Imagebrush as the Background for the Button
          myButton.Background = backgroundImage;
 
          myButton.Content = "Click Here";
          myButton.IsEnabled = true;
          myButton.HorizontalAlignment = HorizontalAlignment.Left;
 
          // Add the Button to the Chart's Toolbar
          chartWindow.MainMenu.Add(myButton);
 
          //Prevent the Button From Displaying when WorkSpace Opens if it is not in an active tab
          myButton.Visibility = Visibility.Collapsed;
          foreach (TabItem tab in this.chartWindow.MainTabControl.Items)
          {
              if ((tab.Content as ChartTab).ChartControl == this.ChartControl

                   && tab == this.chartWindow.MainTabControl.SelectedItem)
              {
                  myButton.Visibility = Visibility.Visible;
              }
          }
          IsToolBarButtonAdded = true;
      }));
  }

  private void DisposeCleanUp()
  {
      //ChartWindow Null Check
      if (chartWindow != null)
      {
          //Dispatcher used to Assure Executed on UI Thread
          ChartControl.Dispatcher.InvokeAsync((Action)(() =>
          {
              //Button Null Check
              if (myButton != null)
              {
                  //Remove Button from Indicator's Chart ToolBar
                  chartWindow.MainMenu.Remove(myButton);
              }
          }));
      }
  }
}
```

#### Example 3

```csharp
//Add the following Using statements
using System.Windows.Media.Imaging;
using System.Windows.Controls;

public class addButton : Indicator
{
  // Define a Chart object to refer to the chart on which the indicator resides
  private Chart chartWindow;

  // Define a Button
  private System.Windows.Controls.Button myButton = null;

  // Instantiate a BitmapImage to hold an image
  BitmapImage myBitmapImage = new BitmapImage();

  // Instantiate an ImageBrush to apply to the Button
  ImageBrush backgroundImage = new ImageBrush();

  private bool IsToolBarButtonAdded;

  protected override void OnStateChange()
  {
      if (State == State.Configure)
      {
          // Assign an image on the filesystem to the BitmapImage.

           // This example assumes that a jpg image named "ButtonBackground" resides in the install directory
          myBitmapImage.BeginInit();
          myBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "ButtonBackground.jpg");
          myBitmapImage.EndInit();
 
          // Assign the BitmapImage as the ImageSource of the ImageBrush
          backgroundImage.ImageSource = myBitmapImage;
      }
      else if (State == State.Historical)
      {
          //Call the custom addButtonToToolbar method in State.Historical to ensure it is only done when applied to a chart

           // -- not when loaded in the Indicators window
          if (!IsToolBarButtonAdded) AddButtonToToolbar();
      }
      else if (State == State.Terminated)
      {
          //Call a custom method to dispose of any leftover objects in State.Terminated
          DisposeCleanUp();
      }
  }

  private void AddButtonToToolbar()
  {
      // Use this.Dispatcher to ensure code is executed on the proper thread
      ChartControl.Dispatcher.InvokeAsync((Action)(() =>
      {

          //Obtain the Chart on which the indicator is configured
          chartWindow = Window.GetWindow(this.ChartControl.Parent) as Chart;
          if (chartWindow == null)
          {
              Print("chartWindow == null");
              return;
          }
 
          // Create a style to apply to the button
          Style s = new Style();
          s.TargetType = typeof(System.Windows.Controls.Button);
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontSizeProperty, 11.0));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.BackgroundProperty, Brushes.Orange));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.ForegroundProperty, Brushes.Black));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontFamilyProperty, new FontFamily("Arial")));
          s.Setters.Add(new Setter(System.Windows.Controls.Button.FontWeightProperty, FontWeights.Bold));
 
          // Instantiate the Button
          myButton = new System.Windows.Controls.Button();
 
          //Set Button Style            
          myButton.Style = s;
 
          // Set the Imagebrush as the Background for the Button
          myButton.Background = backgroundImage;
 
          myButton.Content = "Click Here";
          myButton.IsEnabled = true;
          myButton.HorizontalAlignment = HorizontalAlignment.Left;
 
          // Add the Button to the Chart's Toolbar
          chartWindow.MainMenu.Add(myButton);
 
          //Prevent the Button From Displaying when WorkSpace Opens if it is not in an active tab
          myButton.Visibility = Visibility.Collapsed;
          foreach (TabItem tab in this.chartWindow.MainTabControl.Items)
          {
              if ((tab.Content as ChartTab).ChartControl == this.ChartControl

                   && tab == this.chartWindow.MainTabControl.SelectedItem)
              {
                  myButton.Visibility = Visibility.Visible;
              }
          }
          IsToolBarButtonAdded = true;
      }));
  }

  private void DisposeCleanUp()
  {
      //ChartWindow Null Check
      if (chartWindow != null)
      {
          //Dispatcher used to Assure Executed on UI Thread
          ChartControl.Dispatcher.InvokeAsync((Action)(() =>
          {
              //Button Null Check
              if (myButton != null)
              {
                  //Remove Button from Indicator's Chart ToolBar
                  chartWindow.MainMenu.Remove(myButton);
              }
          }));
      }
  }
}
```

---

## 68. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_historical_bid_ask_serie

**Captured:** 2025-07-07T18:20:34.360Z

### Page Structure

- Using Historical Bid/Ask Series
  - Historical Bid/Ask Series Overview
  - Note
  - Note
  - Accessing Bid/Ask Series
  - Example
      - ON THIS PAGE
- Using Historical Bid/Ask Series
  - Historical Bid/Ask Series Overview
  - Note
  - Note
  - Accessing Bid/Ask Series
  - Example
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing Historical Bid/Ask SeriesHistorical Bid/Ask Series OverviewNinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:NoteYou can have multiple bid/ask/last series in your NinjaScript indicator/strategy. Please use the AddDataSeries() method to add these series to your script.The historical bid/ask series holds all bid/ask events sent out by the exchange. This would not be equivalent to the bid/ask at a specific time a trade went off.When processing your NinjaScript, the historical bid/ask series would have the historical portion triggered in the OnBarUpdate() method only. OnMarketData() method events for the historical bid/ask series would only be triggered in real-time.NoteTips:For using OnMarketData() events historically, please see the educational topic on Developing for Tick Replay.Changing the price type used for the primary Bars object to which a script is applied can be done in the Data Series window from any open chart.Accessing Bid/Ask SeriesWhen calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.Exampleprotected override void OnStateChange()
{
  if (State == State.Configure)
  {
      // Add an AAPL data series using the Ask series
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Ask);

      //Add another AAPL data series using the Bid series, with other settings identical
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Bid);
  }
}
ON THIS PAGEHistorical Bid/Ask Series OverviewAccessing Bid/Ask SeriesExampleUsing Historical Bid/Ask SeriesHistorical Bid/Ask Series OverviewNinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:NoteYou can have multiple bid/ask/last series in your NinjaScript indicator/strategy. Please use the AddDataSeries() method to add these series to your script.The historical bid/ask series holds all bid/ask events sent out by the exchange. This would not be equivalent to the bid/ask at a specific time a trade went off.When processing your NinjaScript, the historical bid/ask series would have the historical portion triggered in the OnBarUpdate() method only. OnMarketData() method events for the historical bid/ask series would only be triggered in real-time.NoteTips:For using OnMarketData() events historically, please see the educational topic on Developing for Tick Replay.Changing the price type used for the primary Bars object to which a script is applied can be done in the Data Series window from any open chart.Accessing Bid/Ask SeriesWhen calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.Exampleprotected override void OnStateChange()
{
  if (State == State.Configure)
  {
      // Add an AAPL data series using the Ask series
      AddDataSeries("AAPL", BarsPeriodTyp

[Content truncated...]


### Code Examples

#### Example 1

```csharp
protected override void OnStateChange()
{
  if (State == State.Configure)
  {
      // Add an AAPL data series using the Ask series
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Ask);

      //Add another AAPL data series using the Bid series, with other settings identical
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Bid);
  }
}
```

#### Example 2

```csharp
protected override void OnStateChange()
{
  if (State == State.Configure)
  {
      // Add an AAPL data series using the Ask series
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Ask);

      //Add another AAPL data series using the Bid series, with other settings identical
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Bid);
  }
}
```

#### Example 3

```csharp
protected override void OnStateChange()
{
  if (State == State.Configure)
  {
      // Add an AAPL data series using the Ask series
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Ask);

      //Add another AAPL data series using the Bid series, with other settings identical
      AddDataSeries("AAPL", BarsPeriodType.Minute, 30, MarketDataType.Bid);
  }
}
```

---

## 69. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_images_and_geometry_with_custom_icons

**Captured:** 2025-07-07T18:20:38.345Z

### Page Structure

- Using Images and Geometry with Custom Icons
  - Custom Icon Overview
  - Using an Image as an Icon
  - Note
  - Using Geometry on an Icon
      - ON THIS PAGE
- Using Images and Geometry with Custom Icons
  - Custom Icon Overview
  - Using an Image as an Icon
  - Note
  - Using Geometry on an Icon
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing Images and Geometry with Custom IconsCustom Icon OverviewWhen overriding the Icon method in a Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displayed on the icon, including UniCode characters (if they exist in the icon pack for the font family used in NinjaTrader), custom Geometry Paths from the System.Windows.Shapes namespace, or image files. Using an image file for a custom icon can allow the flexibility of creating your icon's visuals outside of your code via image editing software. For more information about adding custom Icons, see the "Icon" page under the topics for each of the NinjaScript object types listed above.Using an Image as an IconThe process for using an image as an icon is fairly straightforward using WPF objects, and is the same for different NinjaScript objects.Instantiate a new BitmapImage objectAssign a Uri to the BitmapImage, pointing to an image fileInstantiate a Grid of the same dimensions as the iconInstantiate an Image objectAssign the BitmapImage as the Image's SourceAdd the Image to the GridReturn the Grid by overriding the Icon propertyNoteBe careful to instantiate the Grid to be same size as the needed icon. Some icon sizes differ from others. For example, the icon for Share Services is substantially larger than the icon for a Chart Style in the Chart Toolbar.// Add the following Using statements
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;

BitmapImage iconBitmapImage = new BitmapImage();

protected override void OnStateChange()
{
  if (State == State.Configure)
  {
    // Set the BitmapImage's UriSource to the location of an image file
      iconBitmapImage.BeginInit();
      iconBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "icon.jpg");
      iconBitmapImage.EndInit();
  }
}

// Override Icon (read-only) to return the custom Grid and Image
public override object Icon
{
  get
  {
      // Instantiate a Grid on which to place the image
      Grid myCanvas = new Grid { Height = 16, Width = 16 };

      // Instantiate an Image to place on the Grid
      Image image = new Image
      {
          Height = 16,
          Width = 16,
          Source = iconBitmapImage
      };
 
      // Add the image to the Grid
      myCanvas.Children.Add(image);
 
      return myCanvas;
  }
}
Using Geometry on an IconCustom geometry Paths can be used to draw and fill custom shapes, which can then be applied directly to a Canvas returned for use in an Icon. The process for using a Path is similar to that for using an Image:Instantiate a new Path objectInstantiate a Grid of the same dimensions as the iconDefine the visual properties of the PathAdd the Path to the GridReturn the Grid by overriding the Icon property// Add the following namespace to use Path objects
using System.Windows.Shapes;

using System.Windows.Controls;

public override object Icon
{
  get
  {
      // Instantiate a Grid on which to place the Path
      Grid myCanvas = new Grid { Height = 16, Width = 16 };

      // Instantiate a Path object on which to draw geometry
      System.Windows.Shapes.Path myPath = new System.Windows.Shapes.Path();
 
      // Define the Path's visual properties
      myPath.Fill = Brushes.Red;
      myPath.Data = System.Windows.Media.Geometry.Parse("M 0 0 L 5 0 L 5 5 L 10 5 L 10 0 L 15 0 L 15 5 L 10 5 L 10 10 L 5 10 L 5 5 L 0 5 Z");
 
      // Add the Path to the Canvas, then return the Canvas
      myCanvas.Children.Add(myPath);
      return myCanvas;
  }
}
ON THIS PAGECustom Icon OverviewUsing an Image as an IconUsing Geometry on an IconUsing Images and Geometry with Custom IconsCustom Icon OverviewWhen overriding the Icon method in a Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displa

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// Add the following Using statements
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;

BitmapImage iconBitmapImage = new BitmapImage();

protected override void OnStateChange()
{
  if (State == State.Configure)
  {
    // Set the BitmapImage's UriSource to the location of an image file
      iconBitmapImage.BeginInit();
      iconBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "icon.jpg");
      iconBitmapImage.EndInit();
  }
}

// Override Icon (read-only) to return the custom Grid and Image
public override object Icon
{
  get
  {
      // Instantiate a Grid on which to place the image
      Grid myCanvas = new Grid { Height = 16, Width = 16 };

      // Instantiate an Image to place on the Grid
      Image image = new Image
      {
          Height = 16,
          Width = 16,
          Source = iconBitmapImage
      };
 
      // Add the image to the Grid
      myCanvas.Children.Add(image);
 
      return myCanvas;
  }
}
```

#### Example 2

```csharp
// Add the following Using statements
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;

BitmapImage iconBitmapImage = new BitmapImage();

protected override void OnStateChange()
{
  if (State == State.Configure)
  {
    // Set the BitmapImage's UriSource to the location of an image file
      iconBitmapImage.BeginInit();
      iconBitmapImage.UriSource = new Uri(NinjaTrader.Core.Globals.InstallDir + "icon.jpg");
      iconBitmapImage.EndInit();
  }
}

// Override Icon (read-only) to return the custom Grid and Image
public override object Icon
{
  get
  {
      // Instantiate a Grid on which to place the image
      Grid myCanvas = new Grid { Height = 16, Width = 16 };

      // Instantiate an Image to place on the Grid
      Image image = new Image
      {
          Height = 16,
          Width = 16,
          Source = iconBitmapImage
      };
 
      // Add the image to the Grid
      myCanvas.Children.Add(image);
 
      return myCanvas;
  }
}
```

#### Example 3

```csharp
// Add the following namespace to use Path objects
using System.Windows.Shapes;

using System.Windows.Controls;

public override object Icon
{
  get
  {
      // Instantiate a Grid on which to place the Path
      Grid myCanvas = new Grid { Height = 16, Width = 16 };

      // Instantiate a Path object on which to draw geometry
      System.Windows.Shapes.Path myPath = new System.Windows.Shapes.Path();
 
      // Define the Path's visual properties
      myPath.Fill = Brushes.Red;
      myPath.Data = System.Windows.Media.Geometry.Parse("M 0 0 L 5 0 L 5 5 L 10 5 L 10 0 L 15 0 L 15 5 L 10 5 L 10 10 L 5 10 L 5 5 L 0 5 Z");
 
      // Add the Path to the Canvas, then return the Canvas
      myCanvas.Children.Add(myPath);
      return myCanvas;
  }
}
```

---

## 70. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/using_sharpdx_for_custom_chart_rendering

**Captured:** 2025-07-07T18:20:43.362Z

### Page Structure

- Using SharpDX for Custom Chart Rendering
  - Understanding the SharpDX .NET Library
  - Note
  - SharpDX Vectors and Charting Coordinates
    - Understanding the SharpDX.Vector2
  - Note
    - Calculating Chart Coordinates
  - Note
  - SharpDX Brush Resources
    - Understanding SharpDX Brush Resources
    - Describing SolidColorBrush Colors
  - Note
    - Converting SharpDX Brushes
  - Warning
  - Note
  - SharpDX RenderTarget
    - Understanding the RenderTarget
    - Sequencing RenderTarget commands
  - Note
    - Using the RenderTarget with Device Resources
  - Warning
  - SharpDX Lines and Shapes
    - RenderTarget Draw Methods
  - Note
    - Line
    - Rectangle
    - Ellipse
    - Geometry
  - Warning
  - Note
  - SharpDX Text Rendering
    - Using SharpDX for rendering Text
  - Note
    - Formatting Text
  - Warning
    - Converting Text
    - Text Layouts
    - Measuring Text Layouts
  - Note
  - SharpDX Stroke Style
    - Using the StrokeStyle Object
  - Note
  - Warning
  - Note
    - Creating a Custom DashStyle
  - Best Practices for SharpDX Resources
    - Understanding Device-dependent vs Device-independent resources
    - Device-independent resources
  - Note
    - SharpDX DisposeBase
  - Warning
  - Note
    - Other Best Practices
      - ON THIS PAGE
- Using SharpDX for Custom Chart Rendering
  - Understanding the SharpDX .NET Library
  - Note
  - SharpDX Vectors and Charting Coordinates
    - Understanding the SharpDX.Vector2
  - Note
    - Calculating Chart Coordinates
  - Note
  - SharpDX Brush Resources
    - Understanding SharpDX Brush Resources
    - Describing SolidColorBrush Colors
  - Note
    - Converting SharpDX Brushes
  - Warning
  - Note
  - SharpDX RenderTarget
    - Understanding the RenderTarget
    - Sequencing RenderTarget commands
  - Note
    - Using the RenderTarget with Device Resources
  - Warning
  - SharpDX Lines and Shapes
    - RenderTarget Draw Methods
  - Note
    - Line
    - Rectangle
    - Ellipse
    - Geometry
  - Warning
  - Note
  - SharpDX Text Rendering
    - Using SharpDX for rendering Text
  - Note
    - Formatting Text
  - Warning
    - Converting Text
    - Text Layouts
    - Measuring Text Layouts
  - Note
  - SharpDX Stroke Style
    - Using the StrokeStyle Object
  - Note
  - Warning
  - Note
    - Creating a Custom DashStyle
  - Best Practices for SharpDX Resources
    - Understanding Device-dependent vs Device-independent resources
    - Device-independent resources
  - Note
    - SharpDX DisposeBase
  - Warning
  - Note
    - Other Best Practices
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXUsing SharpDX for Custom Chart RenderingUnderstanding the SharpDX .NET LibraryNinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.NoteTips:There are several pre-installed examples of OnRender() and SharpDX objects used in the NinjaTrader.Custom project.  For starters, please look at the SampleCustomRender indicator fileAlthough not entirely identical, the SharpDX wrapper is designed to resemble System.Drawing namespace; experienced GDI developers will be familiar with concepts discussed in this section.Microsoft provides various DirectX Programming Guides aimed to educate users with the underlying C++ DirectX API.  While SharpDX (C#) syntax is different, you may find these guides helpful for understanding SharpDX concepts not offered by this guide.There are three main SharpDX namespaces you need to be familiar with:SharpDXContains basic objects used by SharpDX.SharpDX.Direct2D1Contains objects used for rendering for 2D geometry, bitmaps, and text.SharpDX.DirectWriteContains objects used for text renderingThe rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.SharpDX Vectors and Charting CoordinatesUnderstanding the SharpDX.Vector2SharpDX Draw methods use a SharpDX.Vector2 object which describes where to render a command relative to the chart panel.  These Vector2 objects can be thought as a two-dimensional point in the chart panels X and Y axis. Since the chart canvas used to draw on consists of the full panel of the chart, a vector using a value of 0 for both the X and Y coordinates would  be located in the top left corner of the chart:// creates a vector located at the top left corner of the chart  
float x = 0;  
float y = 0;  
SharpDX.Vector2 myVector2 = new Vector2(x, y);
NoteYou can learn about Understanding Chart Canvas Coordinates on another topicVector2 objects contain X and Y properties helpful to recalculate new properties based on the initial vector:float width = endPoint.X - startPoint.X;

float height = endPoint.Y - startPoint.Y;
Additionally, you can recalculate a new vector from existing vector objects:SharpDX.Vector2 center = (startPoint + endPoint) / 2;
It is also helpful to know that Vector2 objects are similar to the Windows Point structure and these two types can be used interchangeably.  Depending on the mechanism used to obtain user input or other application values, you may receive the coordinates in a Point.  For convenience, NinjaTrader provides a DXExtension.ToVector2() method used for converting between these two objects if needed:SharpDX.Vector2 dxVector2 = wpfPoint.ToVector2();
Calculating Chart CoordinatesIf you simply used a vector with static values, your Vector2 objects would never change, and your drawing would remain fixed on a particular area of the chart (which may be desired).  However, since NinjaTrader charts are dynamic and responded to various market data updates, scroll, resize, and scale operations - you

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// creates a vector located at the top left corner of the chart  
float x = 0;  
float y = 0;  
SharpDX.Vector2 myVector2 = new Vector2(x, y);
```

#### Example 2

```csharp
// creates a vector located at the top left corner of the chart  
float x = 0;  
float y = 0;  
SharpDX.Vector2 myVector2 = new Vector2(x, y);
```

#### Example 3

```csharp
float width = endPoint.X - startPoint.X;

float height = endPoint.Y - startPoint.Y;
```

---

## 71. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/working_with_brushes

**Captured:** 2025-07-07T18:20:48.365Z

### Page Structure

- Working with Brushes
  - Note
  - Understanding predefined brushes
    - Using Predefined Brushes
  - Note
  - Note
  - Understanding custom brushes
    - Creating a Custom Solid Color Brush
  - Note
  - Warning
    - Creating a Transparent Solid Color Brush
  - Note
  - Warning
  - Using brushes defined on the user interface
    - Saving a Brush as a user defined property (Serialization)
  - Note
    - Adding a User Defined Brush to the Color Picker
  - Using advanced brush types (SharpDX)
    - Understanding SharpDX Brushes
  - Note
    - Creating a SharpDX Brush
  - Warning
    - Converting to SharpDX Brush
  - Warning
    - Disposing DXBrush
  - Warning
    - Using Complex Brushes
      - ON THIS PAGE
- Working with Brushes
  - Note
  - Understanding predefined brushes
    - Using Predefined Brushes
  - Note
  - Note
  - Understanding custom brushes
    - Creating a Custom Solid Color Brush
  - Note
  - Warning
    - Creating a Transparent Solid Color Brush
  - Note
  - Warning
  - Using brushes defined on the user interface
    - Saving a Brush as a user defined property (Serialization)
  - Note
    - Adding a User Defined Brush to the Color Picker
  - Using advanced brush types (SharpDX)
    - Understanding SharpDX Brushes
  - Note
    - Creating a SharpDX Brush
  - Warning
    - Converting to SharpDX Brush
  - Warning
    - Disposing DXBrush
  - Warning
    - Using Complex Brushes
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXWorking with BrushesIn order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.NoteThe following document is written in sequential fashion, starting with the most simple concepts, to the more advance topics.  The majority of the brushes discussed in this document will be referred to as "WPF" brushes which exist in the System.Windows.Media namespace, however there are also "SharpDX" brushes which exist in the 3rd party SharpDX.Direct2D1 namespace used for advanced chart rendering.  Advanced brush types should ONLY be used by experienced programmers familiar with .NET graphics functionality.Understanding predefined brushesUsing Predefined BrushesFor convenience, the .NET Framework supplies a collection of static predefined Brushes, such as Red or Green.  The advantage to using these brushes is that they are readily available, properly named to quickly find a simple color value, and can be reused on-the-fly without having to recreate an instance of the brush at run time, and do not need to be otherwise managed.  There are 256 predefined named brushes which are available in the Brushes class.  You can browse this list in the NinjaScript editor just by typing Brushes. and using Intelliprompt to find the desired named brush of your choice.NoteSince predefined brushes are static, properties of the brush object (such as Color, Opacity, etc.) CANNOT be modified.  However, this also means predefined brushes are thread-safe and do NOT need to be frozen.  For customizing and freezing a brush, please see the section below on Creating a Custom Solid Color Brush.|NoteTip:  You can also find a list of these predefined brushes as well as their hexadecimal value on the MSDN article for the Brushes Class|// set the chart's background color to a predefined "Blue" brush  
BackBrush = Brushes.Blue;  
   
//draw a line using a predefined "LimeGreen" brush.  
Draw.Line(this, "tag1", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);|   |
Understanding custom brushesCreating a Custom Solid Color BrushIn cases where you would like more specific color than one of the predefined brushes, you can optionally create your own Brush object to be used for custom rendering.  In order to achieve this, you will need to initiate your own custom brush object, where you can then specify your color using RGB (red, green, blue) values Color.FromRgb().NoteAnytime you create a custom brush that will be used by NinjaTrader rendering it must be frozen using the .Freeze()  method due to the multi-threaded nature of NinjaTrader.You may have up to 65535 unique Brush instances, therefore, using static predefined brushes (as in the section above) should be favored.  Alternatively,  in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.|// initiate new solid color brush with custom blue color  
Brush myBrush = new SolidColorBrush(Color.FromRgb(56, 120, 153));  
myBrush.Freeze();  

Draw.Line(this, "tag1", true, 10, 1000, 0, 1001, myBrush, DashStyleHelper.Dot, 2);
WarningIf you do not call .Freeze() on a custom defined brush WILL eventually result in threading errors should you try to modify or access that brush after it is defined.Creating a Transparent Solid Color BrushYou can create a transparent brush using the Color.FromArgb() where the A parameter defines alpha transparency.NoteAnytime you create a custom brush that will be used by NinjaTrader rendering it must be frozen using the .Freeze()  method due to the multi-threaded nature of NinjaTrader.// initiate new solid color

[Content truncated...]


### Code Examples

#### Example 1

```csharp
// set the chart's background color to a predefined "Blue" brush  
BackBrush = Brushes.Blue;  
   
//draw a line using a predefined "LimeGreen" brush.  
Draw.Line(this, "tag1", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);|   |
```

#### Example 2

```csharp
// set the chart's background color to a predefined "Blue" brush  
BackBrush = Brushes.Blue;  
   
//draw a line using a predefined "LimeGreen" brush.  
Draw.Line(this, "tag1", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);|   |
```

#### Example 3

```csharp
// initiate new solid color brush with custom blue color  
Brush myBrush = new SolidColorBrush(Color.FromRgb(56, 120, 153));  
myBrush.Freeze();  

Draw.Line(this, "tag1", true, 10, 1000, 0, 1001, myBrush, DashStyleHelper.Dot, 2);
```

---

## 72. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/working_with_chart_object_coordinates

**Captured:** 2025-07-07T18:20:53.349Z

### Page Structure

- Working with Chart Object Coordinates
  - Understanding Chart Canvas Coordinates
  - Understanding Chart Areas
      - ON THIS PAGE
- Working with Chart Object Coordinates
  - Understanding Chart Canvas Coordinates
  - Understanding Chart Areas
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXWorking with Chart Object CoordinatesUnderstanding Chart Canvas CoordinatesThe chart canvas represents the portion of a chart window on which objects can be painted (the area outlined in blue in the image below). The canvas area is measured by an x-axis and y-axis independent of the price and time-axis of the chart itself. When working with coordinates on a chart canvas, it is important to note that the origin point (coordinates 0,0) is in the top-left corner of the canvas, NOT the bottom-left. Moving down the canvas increases the y-coordinate, and moving the the right on the canvas increases the x-coordinate.Understanding Chart AreasWhen using ChartControl properties and methods, it is important to understand the layout of a chart window, and which specific area of the window is being measured by a specific property. The image below shows the three primary areas of a chart window.The three regions shaded in the image above are labeled as follows:The chart canvas covers the area in which bars, drawing objects, and indicator plots can be painted. It is bounded on the bottom by the x-axis, and on the right, left, or both by the y-axis. This is measured by properties such as CanvasLeft and CanvasRight.The y-axis extends vertically from the chart's horizontal scroll bar to the top of the chart canvas, and can be displayed to the right or left (or both) of the canvas area, depending the "Scale Justification" properties of the Bars object or indicators painted on the chart. This is measured by properties such as AxisYLeftWidth and AxisYRightWidth.The x-axis sits beneath the chart canvas, and extends horizontally from the left edge of the chart canvas (or the left edge of the y-axis if it is visible on the left) to the right edge of the y-axis applied to the right of the canvas (or the right edge of the canvas itself if the y-axis is not visible on the right). This is measured by properties such as AxisXHeight.ON THIS PAGEUnderstanding Chart Canvas CoordinatesUnderstanding Chart AreasWorking with Chart Object CoordinatesUnderstanding Chart Canvas CoordinatesThe chart canvas represents the portion of a chart window on which objects can be painted (the area outlined in blue in the image below). The canvas area is measured by an x-axis and y-axis independent of the price and time-axis of the chart itself. When working with coordinates on a chart canvas, it is important to note that the origin point (coordinates 0,0) is in the top-left corner of the canvas, NOT the bottom-left. Moving down the canvas increases the y-coordinate, and moving the the right on the canvas increases the x-coordinate.Understanding Chart AreasWhen using ChartControl properties and methods, it is important to understand the layout of a chart window, and which specific area of the window is being measured by a specific property. The image below shows the three primary areas of a chart window.The three regions shaded in the image above are labeled as follows:The chart canvas covers the area in which bars, drawing objects, and indicator plots can be painted. It is bounded on the bottom by the x-axis, and on the right, left, or both by the y-axis. This is measured by properties such as CanvasLeft and CanvasRight.The y-axis extends vertically from the chart's horizontal scroll bar to the top of the chart canvas, and can be displayed to the right or left (or both) of the canvas area, depending the "Scale Justification" properties of the Bars object or indicators painted on the chart. This is measured by properties such as AxisYLeftWidth and AxisYRightWidth.The x-axis sits beneath the chart canvas, and extends horizontally from the left edge of the chart canvas (or the left edge of the y-axis if it is visible on the left) to the right edge of the y-axis applied to the right of the canvas (or the right edge of the canvas itself 

[Content truncated...]


---

## 73. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/working_with_pixel_coordinates

**Captured:** 2025-07-07T18:20:57.347Z

### Page Structure

- Working with Pixel Coordinates
  - Understanding Device Pixels vs. Application Pixels (WPF)
  - Converting to Device Pixels
  - Example
      - ON THIS PAGE
- Working with Pixel Coordinates
  - Understanding Device Pixels vs. Application Pixels (WPF)
  - Converting to Device Pixels
  - Example
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXWorking with Pixel CoordinatesUnderstanding Device Pixels vs. Application Pixels (WPF)When working with pixel coordinates (for example, when using SharpDX drawing methods for custom drawing), it is important to note if the coordinates specified in method arguments refer to application pixels (i.e., WPF coordinates), or the larger concept of Device Independent Pixels (DIP).The physical size of an application-specific pixel can vary based on PC hardware and operating-system settings, which introduces a challenge for developers using pixel coordinates for processes such as custom drawing on a chart canvas. By specifying the number of pixels when defining a coordinate, the object placed at that coordinate could render in a very different position depending on the users display settings. Device Independent Pixels provide a way to measure or quantify pixel coordinates without being impacted by different sizes of application pixels. Specifying Device Independent Pixels can ensure that objects render in the intended location or position, regardless of these unpredictable factors.Converting to Device PixelsNinjaScript provides helper methods to convert from application pixels to device pixels (or vice versa) within the ChartingExtensions class. Since some NinjaScript methods and properties return application pixels where device pixels are needed, using these helper methods can provide great flexibility by allowing you to define physical application pixels, then converting them to device independent pixels before passing them to a method. Using this process, the application pixel values used will result in objects being rendered exactly where intended.Exampleprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
  // get the point the user clicked, (which returns application pixel)
  Point clickPoint = chartControl.MouseDownPoint;

  // Convert the clickPoint X and Y coordinates to device independent pixels (DIP)
  // This will ensure that the MouseDownPoint will work across all screen displays
  clickPoint.X = ChartingExtensions.ConvertToHorizontalPixels(clickPoint.X, chartControl.PresentationSource);
  clickPoint.Y = ChartingExtensions.ConvertToVerticalPixels(clickPoint.Y, chartControl.PresentationSource);

  // set the location (vector) from the user clickPoint
  SharpDX.Vector2 vectorForEllipse = clickPoint.ToVector2();

  // create the shape (ellipse), and color (brush) for our object to render
  SharpDX.Direct2D1.Ellipse ellipse = new SharpDX.Direct2D1.Ellipse(vectorForEllipse, 10f, 10f);
  SharpDX.Direct2D1.Brush ellipseBrushDX = Brushes.Blue.ToDxBrush(RenderTarget);

  // finally, render a ellipse at the exact point the user clicked
  RenderTarget.FillEllipse(ellipse, ellipseBrushDX);
}
ON THIS PAGEUnderstanding Device Pixels vs. Application Pixels (WPF)Converting to Device PixelsExampleWorking with Pixel CoordinatesUnderstanding Device Pixels vs. Application Pixels (WPF)When working with pixel coordinates (for example, when using SharpDX drawing methods for custom drawing), it is important to note if the coordinates specified in method arguments refer to application pixels (i.e., WPF coordinates), or the larger concept of Device Independent Pixels (DIP).The physical size of an application-specific pixel can vary based on PC hardware and operating-system settings, which introduces a challenge for developers using pixel coordinates for processes such as custom drawing on a chart canvas. By specifying the number of pixels when defining a coordinate, the object placed at that coordinate could render in a very different position depending on the users display settings. Device Independent Pixels provide a way to measure or quantify pixel coordinates without being impacted by different sizes of application pixels. Specifying Device Independent Pixels can ensure 

[Content truncated...]


### Code Examples

#### Example 1

```csharp
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
  // get the point the user clicked, (which returns application pixel)
  Point clickPoint = chartControl.MouseDownPoint;

  // Convert the clickPoint X and Y coordinates to device independent pixels (DIP)
  // This will ensure that the MouseDownPoint will work across all screen displays
  clickPoint.X = ChartingExtensions.ConvertToHorizontalPixels(clickPoint.X, chartControl.PresentationSource);
  clickPoint.Y = ChartingExtensions.ConvertToVerticalPixels(clickPoint.Y, chartControl.PresentationSource);

  // set the location (vector) from the user clickPoint
  SharpDX.Vector2 vectorForEllipse = clickPoint.ToVector2();

  // create the shape (ellipse), and color (brush) for our object to render
  SharpDX.Direct2D1.Ellipse ellipse = new SharpDX.Direct2D1.Ellipse(vectorForEllipse, 10f, 10f);
  SharpDX.Direct2D1.Brush ellipseBrushDX = Brushes.Blue.ToDxBrush(RenderTarget);

  // finally, render a ellipse at the exact point the user clicked
  RenderTarget.FillEllipse(ellipse, ellipseBrushDX);
}
```

#### Example 2

```csharp
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
  // get the point the user clicked, (which returns application pixel)
  Point clickPoint = chartControl.MouseDownPoint;

  // Convert the clickPoint X and Y coordinates to device independent pixels (DIP)
  // This will ensure that the MouseDownPoint will work across all screen displays
  clickPoint.X = ChartingExtensions.ConvertToHorizontalPixels(clickPoint.X, chartControl.PresentationSource);
  clickPoint.Y = ChartingExtensions.ConvertToVerticalPixels(clickPoint.Y, chartControl.PresentationSource);

  // set the location (vector) from the user clickPoint
  SharpDX.Vector2 vectorForEllipse = clickPoint.ToVector2();

  // create the shape (ellipse), and color (brush) for our object to render
  SharpDX.Direct2D1.Ellipse ellipse = new SharpDX.Direct2D1.Ellipse(vectorForEllipse, 10f, 10f);
  SharpDX.Direct2D1.Brush ellipseBrushDX = Brushes.Blue.ToDxBrush(RenderTarget);

  // finally, render a ellipse at the exact point the user clicked
  RenderTarget.FillEllipse(ellipse, ellipseBrushDX);
}
```

#### Example 3

```csharp
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
  // get the point the user clicked, (which returns application pixel)
  Point clickPoint = chartControl.MouseDownPoint;

  // Convert the clickPoint X and Y coordinates to device independent pixels (DIP)
  // This will ensure that the MouseDownPoint will work across all screen displays
  clickPoint.X = ChartingExtensions.ConvertToHorizontalPixels(clickPoint.X, chartControl.PresentationSource);
  clickPoint.Y = ChartingExtensions.ConvertToVerticalPixels(clickPoint.Y, chartControl.PresentationSource);

  // set the location (vector) from the user clickPoint
  SharpDX.Vector2 vectorForEllipse = clickPoint.ToVector2();

  // create the shape (ellipse), and color (brush) for our object to render
  SharpDX.Direct2D1.Ellipse ellipse = new SharpDX.Direct2D1.Ellipse(vectorForEllipse, 10f, 10f);
  SharpDX.Direct2D1.Brush ellipseBrushDX = Brushes.Blue.ToDxBrush(RenderTarget);

  // finally, render a ellipse at the exact point the user clicked
  RenderTarget.FillEllipse(ellipse, ellipseBrushDX);
}
```

---

## 74. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/working_with_price_series

**Captured:** 2025-07-07T18:21:01.354Z

### Page Structure

- Working with Price Series
  - Price Data Overview
  - Definitions
  - Referencing Series
  - Note
  - Referencing Indicator Data
      - ON THIS PAGE
- Working with Price Series
  - Price Data Overview
  - Definitions
  - Referencing Series
  - Note
  - Referencing Indicator Data
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXWorking with Price SeriesPrice Data OverviewThe core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.DefinitionsISeries<T>Standard bar based price types such as closing, opening, high, low prices and volumeIndicatorCalculated values based on price type values such as a simple moving averageCustom Historical Series<T>Custom calculated values that you wish to store and associate to each historical barReferencing SeriesISeries<T>SyntaxEditor ShortcutDefinitionCloseClose[int barsAgo]"c" + Tab KeyLast traded price of a barOpenOpen[int barsAgo]"o" + Tab KeyOpening price of a barHighHigh[int barsAgo]"h" + Tab KeyHighest traded price of a barLowLow[int barsAgo]"l" + Tab KeyLowest traded price of a barVolumeVolume[int barsAgo]"v" + Tab KeyNumber of shares/contracts traded of a barInputInput[int barsAgo]"i" + Tab KeyDefault price type of a barYou will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:High[1] < High[0];You could write a statement to calculate the average closing price of the last three bars like this:( Close[2] + Close[1] + Close[0] ) / 3;As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.NoteIn most cases, you will access the historical price series using a core event handler such as OnBarUpdate.  For more advance developers, you may find situations where you wish to access historical price series outside of the core event methods, such as your own custom mouse click.  In these advanced scenarios, you may run into situations where the barsAgo pointer is not in sync with the current bar, and may result in errors when trying to obtain this information.  In those cases, please use the Bars.Get...() methods with the absolute bar index (e.g., Bars.GetClose(), Bars.GetTime(), etc.)Referencing Indicator DataNinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.All indicator values can be accessed in the following way:indicator[parameters] (int barsAgo)where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:Close(0] > SMA[20)[0];If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:Close(0] > SMA[High, 20)[0];You could write a statement to see if a 14 period CCI indicator is rising like this:CCI(14)[0] > CCI(14)[1];Value of a 10 period CCI 1 bar ago = CCI(10)[1]Please review the Indicator Methods section for proper syntax for accessing different indicator values.ON THIS PAGEPrice Data OverviewDefinitionsReferencing SeriesReferencing Indicator DataWorking with Price SeriesPrice Data OverviewThe core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. T

[Content truncated...]


### Code Examples

#### Example 1

```csharp
High[1] < High[0];
```

#### Example 2

```csharp
( Close[2] + Close[1] + Close[0] ) / 3;
```

#### Example 3

```csharp
Close(0] > SMA[20)[0];
```

---

## 75. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/reference_samples

**Captured:** 2025-07-07T18:21:06.366Z

### Page Structure

- Reference Samples
  - Reference Samples Overview
      - ON THIS PAGE
- Reference Samples
  - Reference Samples Overview
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping Outside of the NinjaScript EditorAdvanced - Custom DrawingAdvanced - Custom Plot Colors via ThresholdsIntermediate - Historical Custom SeriesIntermediate - Your own SMABeginner - Indicator on IndicatorBeginner - Using price variablesDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesIndicatorStrategyTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXReference SamplesReference Samples OverviewIndicatorIndicator OverviewStrategyStrategy OverviewON THIS PAGEReference Samples OverviewReference SamplesReference Samples OverviewIndicatorIndicator OverviewStrategyStrategy OverviewON THIS PAGEReference Samples Overview

---

## 76. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/calculating_the_highest_high_or_lowest_low_for_a_specified_time_range

**Captured:** 2025-07-07T18:21:12.355Z

### Page Structure

- Calculating the highest high or lowest low for a specified time range
  - Key concepts in this example
  - Important related documentation
  - Import instructions
      - ON THIS PAGE
- Calculating the highest high or lowest low for a specified time range
  - Key concepts in this example
  - Important related documentation
  - Import instructions
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesAddOn Development OverviewC# Method (Functions) ReferenceDeveloping for Tick ReplayDeveloping IndicatorsDeveloping StrategiesHistorical Order Backfill LogicMulti-Threading Consideration for NinjaScriptMulti-Time Frame & InstrumentsNinjaScript LifecycleUsing 3rd Party IndicatorsUsing ATM StrategiesUsing BitmapImage objects with ButtonsUsing Historical Bid/Ask SeriesUsing Images and Geometry with Custom IconsUsing SharpDX for Custom Chart RenderingWorking with BrushesWorking with Chart Object CoordinatesWorking with Pixel CoordinatesWorking with Price SeriesReference SamplesTipsUser-Based Vendor LicensingREFERENCESCommonAdd OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCalculating the highest high or lowest low for a specified time rangeDetermining a high or low value for given time range can be useful.Key concepts in this exampleConverting time to bars ago valuesGetting the highest high and lowest low valuesImportant related documentationGetBar()MAX()MIN()Import instructionsDownload the file contained in this Help Guide topic to your PC desktopFrom the Control Center window, select the menu Tools > Import > NinjaScriptSelect the downloaded fileSampleGetHighLowByTimeRange_NT8.zipON THIS PAGEKey concepts in this exampleImportant related documentationImport instructionsCalculating the highest high or lowest low for a specified time rangeDetermining a high or low value for given time range can be useful.Key concepts in this exampleConverting time to bars ago valuesGetting the highest high and lowest low valuesImportant related documentationGetBar()MAX()MIN()Import instructionsDownload the file contained in this Help Guide topic to your PC desktopFrom the Control Center window, select the menu Tools > Import > NinjaScriptSelect the downloaded fileSampleGetHighLowByTimeRange_NT8.zipON THIS PAGEKey concepts in this exampleImportant related documentationImport instructions

---

## 77. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/adddataseries

**Captured:** 2025-07-07T18:21:22.350Z

### Page Structure

- AddDataSeries()
  - Definition
  - Related Methods and Properties
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddDataSeries()
  - Definition
  - Related Methods and Properties
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddDataSeries()DefinitionAdds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.Related Methods and PropertiesMethod/PropertyDescriptionAddHeikenAshi()This method adds a Heiken Ashi Bars object for multi-series NinjaScript.AddKagi()This method adds a Kagi Bars object for multi-series NinjaScript.AddLineBreak()This method adds a Line Break Bars object for multi-series NinjaScript.AddPointAndFigure()This method adds a Point-and-Figure Bars object for multi-series NinjaScript.AddRenko()This method adds a Renko Bars object for multi-series NinjaScript.AddVolumetric()This method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.BarsArrayAn array holding Bars objects that are added via the AddDataSeries() method.BarsInProgressAn index value of the current Bars object that has called the OnBarUpdate() method.BarsPeriodsHolds an array of BarsPeriod objects synchronized to the number of unique Bars objects held within the parent NinjaScript object.CurrentBarsHolds an array of int values representing the number of the current bar in a Bars object.SyntaxThe following syntax will add another Bars object for the primary instrument of the script.AddDataSeries(BarsPeriod barsPeriod)AddDataSeries(BarsPeriodType periodType, int period)The following syntax allows you to add another Bars object for a different instrument to the script:AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)AddDataSeries(string instrumentName, BarsPeriod barsPeriod)AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)AddDataSeries(string instrumentName) //only for R15 and higherWarningThis method should ONLY be called from the OnStateChange() method during State.Configure.Should your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddDataSeries() calls as those hosted scripts would. For further reference, please also review the 2nd example below and the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & Instruments.Arguments supplied to AddDataSeries() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input). Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided. Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.When adding multiple Data Series of the same instrument and the same Bar Type, the 'barsToLoad' property will only be effective on the first added series. Subsequent series with a different barsToLoad setting will not load a different number of bars than the first series.The AddDataSeries(string instrumentName) overload allows loading a different instrument yet using the same BarsPeriod. This could not be supported for Strategy Analyzer use with the 'Optimize Data Series' option enabled, doing so may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.If your NinjaScript object is using AddDataSeries() allowing to specify a tradingHoursName, please keep in mind that: An indicator / strategy with multiple DataSeries of the same instrument will only process realtime OnBarUpdate() calls when a tick occurs in session of the trading hour template of all added series. Any ticks not processed will be queued and processed as a tick comes in for all subsequent DataSeries.When instantiating indicators in a Multi-Series script in OnStateChange, the input any hosted indicator is run

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddDataSeries(BarsPeriod barsPeriod)
```

#### Example 2

```csharp
AddDataSeries(BarsPeriodType periodType, int period)
```

#### Example 3

```csharp
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
```

---

## 78. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addheikenashi

**Captured:** 2025-07-07T18:21:23.351Z

### Page Structure

- AddHeikenAshi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddHeikenAshi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddHeikenAshi()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Heiken Ashi Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddHeikenAshi() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddHeikenAshi() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the Heiken Ashi bars period. Possible values are: BarsPeriodType.Tick, BarsPeriodType.Volume, BarsPeriodType.Range, BarsPeriodType.Second, BarsPeriodType.Minute, BarsPeriodType.Day, BarsPeriodType.Week, BarsPeriodType.Month, BarsPeriodType.YearbaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barsmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are: MarketDataType.Ask, MarketDataType.Bid, MarketDataType.Last. Note: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should [Break at EOD(https://ninjatrader.com/support/helpGuides/nt8/NT%20HelpGuide%20English.html?break_at_eod.htm). Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddHeikenAshi("MSFT Arca", BarsPeriodType.Minute, 1, MarketDataType.Last);Examplesprotected override void OnStateChange()
{
   if (State == State.SetDefaults)
   {
       Name = "Examples Indicator";            
   }
   else if (State == State.Configure)
   {
       //

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 79. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addheikenashi

**Captured:** 2025-07-07T18:21:25.366Z

### Page Structure

- AddHeikenAshi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddHeikenAshi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddHeikenAshi()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Heiken Ashi Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddHeikenAshi() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddHeikenAshi() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the Heiken Ashi bars period. Possible values are: BarsPeriodType.Tick, BarsPeriodType.Volume, BarsPeriodType.Range, BarsPeriodType.Second, BarsPeriodType.Minute, BarsPeriodType.Day, BarsPeriodType.Week, BarsPeriodType.Month, BarsPeriodType.YearbaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barsmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are: MarketDataType.Ask, MarketDataType.Bid, MarketDataType.Last. Note: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should [Break at EOD(https://ninjatrader.com/support/helpGuides/nt8/NT%20HelpGuide%20English.html?break_at_eod.htm). Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddHeikenAshi("MSFT Arca", BarsPeriodType.Minute, 1, MarketDataType.Last);Examplesprotected override void OnStateChange()
{
   if (State == State.SetDefaults)
   {
       Name = "Examples Indicator";            
   }
   else if (State == State.Configure)
   {
       //

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 80. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addkagi

**Captured:** 2025-07-07T18:21:29.349Z

### Page Structure

- AddKagi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddKagi()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddKagi()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Kagi Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType)AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName)AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddKagi() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddKagi() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the Kagi bars period. Possible values are:BarsPeriodType.DayBarsPeriodType.MinuteBarsPeriodType.SecondBarsPeriodType.TickBarsPeriodType.VolumebaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barsreversalAn int determining the required price movement in the reversal direction before a reversal is identified on the chartreversalTypeAn enum determining the mode reversal period is based. Possible values are:ReversalType.PercentReversalType.TickmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are:MarketDataType.AskMarketDataType.BidMarketDataType.LastNote: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should Break at EOD Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddKagi("MSFT Arca", PeriodType.Minute, 1, 2, ReversalType.Tick, MarketDataType.Last)Examplesprotected override void OnStateChange(

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 81. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addlinebreak

**Captured:** 2025-07-07T18:21:33.350Z

### Page Structure

- AddLineBreak()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddLineBreak()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddLineBreak()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Line Break Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddLineBreak() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddLineBreak() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the LineBreak bars period. Possible values are:BarsPeriodType.DayBarsPeriodType.MinuteBarsPeriodType.SecondBarsPeriodType.TickBarsPeriodType.VolumebaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barslineBreakCountAn int determining the number of bars back used to calculate a line breakmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are:MarketDataType.AskMarketDataType.BidMarketDataType.Last Note: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should Break at EOD Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddLineBreak("MSFT Arca", PeriodType.Minute, 1, 3, MarketDataType.Last)Examplesprotected override void OnStateChange()
{      
   if (State == State.SetDefaults)
   {
     Name = "Examples Indicator";            
   }

   if (State == State.Configure)
   {
     // Add a 1 minute Line Break Bars object for the ES 03-18 - BarsInP

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 82. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addpointandfigure

**Captured:** 2025-07-07T18:21:37.354Z

### Page Structure

- AddPointAndFigure()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddPointAndFigure()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddPointAndFigure()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Point-and-Figure Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType)AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName)AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddPointAndFigure() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddPointAndFigure() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the Point-and-Figure bars period. Possible values are:BarsPeriodType.DayBarsPeriodType.MinuteBarsPeriodType.SecondBarsPeriodType.TickBarsPeriodType.VolumebaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barsboxSizeAn int determining the price movement signified by the X's and O's of a Point-and-Figure chartreversalAn int determining the number of boxes the price needs to move in the reversal direction before a new column will be builtpointAndFigurePriceTypeDetermines where to base reversal calculations. Possible values are:PointAndFigurePriceType.ClosePointAndFigurePriceType.HighsAndLowsmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are:MarketDataType.AskMarketDataType.BidMarketDataType.Last Note: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should Break at EOD. Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the excha

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 83. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addrenko

**Captured:** 2025-07-07T18:21:40.353Z

### Page Structure

- AddRenko()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddRenko()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddRenko()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Renko Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.SyntaxAddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType)AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName)AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName, bool?isResetOnNewTradingDay)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddRenko() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddRenko() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"brickSizeAn int determining the size (in ticks) of each barmarketDataTypeThe MarketDataType used for the bars object (last, bid, ask). Possible values are:MarketDataType.AskMarketDataType.BidMarketDataType.Last Note: Please see the article here on using Bid/Ask series.tradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should Break at EOD. Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddRenko("MSFT Arca", 2, MarketDataType.Last)Examplesprotected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Add a 1 minute Renko Bars object for the ES 03-18 contract - BarsInProgress index = 1 
         AddRenko("ES 03-18", 2, MarketDataType.Last); 
     }
} 
 
protected override void OnBarUpdate() 
{ 
     // Ignore the primary Bars object and only process the Renko Bars object 
     if (BarsInProgress == 1)
     {
         // Do something;
     }
}
ON THIS PAGEDefinitionSyntaxParametersExamplesAddRenko()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Renko Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument Ninja

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType)
```

#### Example 2

```csharp
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName)
```

#### Example 3

```csharp
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName, bool?isResetOnNewTradingDay)
```

---

## 84. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/addvolumetric

**Captured:** 2025-07-07T18:21:43.352Z

### Page Structure

- AddVolumetric()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE
- AddVolumetric()
  - Definition
  - Note
  - Syntax
  - Warning
  - Parameters
  - Note
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXAddVolumetric()DefinitionSimilar to the AddDataSeries() method for adding Bars objects, this method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.NoteWhen running NinjaScript, you will be able to choose the first instrument and bar interval to run on. This first Bars object will carry a BarsInProgress index of 0.In a multi-time frame and multi-instrument NinjaScript, supplementary Bars objects are added via this method in State.Configure state of the OnStateChange() method and given an incremented BarsInProgress index value. See additional information on running multi-bars scripts.The BarsInProgress property can be used to filter updates between different bars seriesIf using OnMarketData(), a subscription will be created on all bars series added in your indicator or strategy strategy (even if the instrument is the same).  The market data subscription behavior occurs both in real-time and during TickReplay historicalFor adding regular Bars types please use AddDataSeries()A Tick Replay indicator or strategy CANNOT use a MarketDataType.Ask or MarketDataType.Bid series.  Please see Developing for Tick Replay for more information.To access additional Volumetric data points programmtically in your NinjaScript studies, please see the example here.SyntaxAddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, int sizeFilter, string tradingHoursName, bool? isResetOnNewTradingDay) (R17 and higher only)WarningThis method should ONLY be called from the OnStateChange() method during State.ConfigureShould your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddVolumetric() calls as those hosted scripts would. For further reference, please also review the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & InstrumentsArguments supplied to AddVolumetric() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input).  Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided.  Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.ParametersinstrumentNameA string determining instrument name such as "MSFT"baseBarsPeriodTypeThe underlying BarsType used for the Volumetric bars period. Possible values are:BarsPeriodType.TickBarsPeriodType.VolumeBarsPeriodType.RangeBarsPeriodType.SecondBarsPeriodType.MinuteBarsPeriodType.DayBarsPeriodType.WeekBarsPeriodType.MonthBarsPeriodType.YearbaseBarsPeriodTypeValueAn int determining the underlying period interval such as "3" for 3 minute barsdeltaTypeThe DeltaType used for the Volumetric bars object delta calculations. Possible values are:VolumetricDeltaType.BidAskVolumetricDetlaType.UpDownTickticksPerLevelAn int setting the aggregation of price levels for the Volumetric bar, pass in a 1 to analyze each price level individuallysizeFilterAn int setting the trade size allowed to count in the delta calculationstradingHoursNameA string determining the trading hours template for the instrumentisResetOnNewTradingDayA nullable bool determining if the Bars object should Break at EOD. Will accept true, false or null as the input.  If null is used, the data series will use the settings of the primary data series.NoteYou can optionally

[Content truncated...]


### Code Examples

#### Example 1

```csharp
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)
```

#### Example 2

```csharp
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)
```

#### Example 3

```csharp
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)
```

---

## 85. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/barsarray

**Captured:** 2025-07-07T18:21:49.348Z

### Page Structure

- BarsArray
  - Definition
  - Property Value
  - Warning
  - Syntax
  - Examples
      - ON THIS PAGE
- BarsArray
  - Definition
  - Property Value
  - Warning
  - Syntax
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXBarsArrayDefinitionAn array holding Bars objects that are added via the AddDataSeries() method. BarsArray can be used as input for indicator methods. This property is of primary value when working with multi-time frame or multi-instrument scripts.Property ValueAn array of Bars objects.WarningThis property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoadedSyntaxBarsArray[int index]Examplesprotected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {
        Name = "Examples Indicator";      
    }
    else if (State == State.Configure)
    {
        // Add a 5 minute Bars object which is added to the BarArray 
        // which will take index 1 since the primary Bars object of the strategy 
        // will be index 0 
        AddDataSeries(BarsPeriodType.Minute, 5); 
    }
} 

protected override void OnBarUpdate() 
{ 
    // Ignore bar update events for the supplementary Bars object added above 
    if (BarsInProgress == 1) 
        return; 

    // Pass in a Bars object as input for the simple moving average method 
    // Evaluates if the 20 SMA of the primary Bars is greater than 
    // the 20 SMA of the secondary Bars added above 
    if (SMA(20)[0] > SMA(BarsArray[1], 20)[0]) 
        EnterLong(); 
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamplesBarsArrayDefinitionAn array holding Bars objects that are added via the AddDataSeries() method. BarsArray can be used as input for indicator methods. This property is of primary value when working with multi-time frame or multi-instrument scripts.Property ValueAn array of Bars objects.WarningThis property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoadedSyntaxBarsArray[int index]Examplesprotected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {
        Name = "Examples Indicator";      
    }
    else if (State == State.Configure)
    {
        // Add a 5 minute Bars object which is added to the BarArray 
        // which will take index 1 since the primary Bars object of the strategy 
        // will be index 0 
        AddDataSeries(BarsPeriodType.Minute, 5); 
    }
} 

protected override void OnBarUpdate() 
{ 
    // Ignore bar update events for the supplementary Bars object added above 
    if (BarsInProgress == 1) 
        return; 

    // Pass in a Bars object as input for the simple moving average method 
    // Evaluates if the 20 SMA of the primary Bars is greater than 
    // the 20 SMA of the secondary Bars added above 
    if (SMA(20)[0] > SMA(BarsArray[1], 20)[0]) 
        EnterLong(); 
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamples

### Code Examples

#### Example 1

```csharp
BarsArray[int index]
```

#### Example 2

```csharp
protected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {
        Name = "Examples Indicator";      
    }
    else if (State == State.Configure)
    {
        // Add a 5 minute Bars object which is added to the BarArray 
        // which will take index 1 since the primary Bars object of the strategy 
        // will be index 0 
        AddDataSeries(BarsPeriodType.Minute, 5); 
    }
} 

protected override void OnBarUpdate() 
{ 
    // Ignore bar update events for the supplementary Bars object added above 
    if (BarsInProgress == 1) 
        return; 

    // Pass in a Bars object as input for the simple moving average method 
    // Evaluates if the 20 SMA of the primary Bars is greater than 
    // the 20 SMA of the secondary Bars added above 
    if (SMA(20)[0] > SMA(BarsArray[1], 20)[0]) 
        EnterLong(); 
}
```

#### Example 3

```csharp
protected override void OnStateChange()
{
    if (State == State.SetDefaults)
    {
        Name = "Examples Indicator";      
    }
    else if (State == State.Configure)
    {
        // Add a 5 minute Bars object which is added to the BarArray 
        // which will take index 1 since the primary Bars object of the strategy 
        // will be index 0 
        AddDataSeries(BarsPeriodType.Minute, 5); 
    }
} 

protected override void OnBarUpdate() 
{ 
    // Ignore bar update events for the supplementary Bars object added above 
    if (BarsInProgress == 1) 
        return; 

    // Pass in a Bars object as input for the simple moving average method 
    // Evaluates if the 20 SMA of the primary Bars is greater than 
    // the 20 SMA of the secondary Bars added above 
    if (SMA(20)[0] > SMA(BarsArray[1], 20)[0]) 
        EnterLong(); 
}
```

---

## 86. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/barsinprogress

**Captured:** 2025-07-07T18:21:53.349Z

### Page Structure

- BarsInProgress
  - Definition
  - Note
  - Property Value
  - Syntax
  - Examples
      - ON THIS PAGE
- BarsInProgress
  - Definition
  - Note
  - Property Value
  - Syntax
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXBarsInProgressDefinitionAn index value of the current Bars object that has called the OnBarUpdate method. In a multi-bars script, the OnBarUpdate() method is called for each Bars object of a script. This flexibility allows you to separate trading logic from different bar events.NoteIn a single Bars script this property will always return an index value of 0 representing the primary Bars and instrument the script is running on.See additional information on running multi-bars scripts.Property ValueAn int value represents the Bars object that is calling the OnBarUpdate() method.SyntaxBarsInProgressExamplesprotected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Add a 5 minute Bars object: BarsInProgress index = 1 
         AddDataSeries(BarsPeriodType.Minute, 5);
     }
} 

protected override void OnBarUpdate() 
{ 
     // Check which Bars object is calling the OnBarUpdate() method 
     if (BarsInProgress == 0) 
     { 
         // A value of zero represents the primary Bars which is the ES 09-14 
         // 1 minute chart. 
         // Do something within the context of the 1 minute Bars here 
     } 
     else if (BarsInProgress == 1) 
     { 
         // A value of 1 represents the secondary 5 minute bars added in OnStateChange() State.Configure 
         // Do something within the context of the 5 minute Bars 
     } 
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamplesBarsInProgressDefinitionAn index value of the current Bars object that has called the OnBarUpdate method. In a multi-bars script, the OnBarUpdate() method is called for each Bars object of a script. This flexibility allows you to separate trading logic from different bar events.NoteIn a single Bars script this property will always return an index value of 0 representing the primary Bars and instrument the script is running on.See additional information on running multi-bars scripts.Property ValueAn int value represents the Bars object that is calling the OnBarUpdate() method.SyntaxBarsInProgressExamplesprotected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Add a 5 minute Bars object: BarsInProgress index = 1 
         AddDataSeries(BarsPeriodType.Minute, 5);
     }
} 

protected override void OnBarUpdate() 
{ 
     // Check which Bars object is calling the OnBarUpdate() method 
     if (BarsInProgress == 0) 
     { 
         // A value of zero represents the primary Bars which is the ES 09-14 
         // 1 minute chart. 
         // Do something within the context of the 1 minute Bars here 
     } 
     else if (BarsInProgress == 1) 
     { 
         // A value of 1 represents the secondary 5 minute bars added in OnStateChange() State.Configure 
         // Do something within the context of the 5 minute Bars 
     } 
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamples

### Code Examples

#### Example 1

```csharp
BarsInProgress
```

#### Example 2

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Add a 5 minute Bars object: BarsInProgress index = 1 
         AddDataSeries(BarsPeriodType.Minute, 5);
     }
} 

protected override void OnBarUpdate() 
{ 
     // Check which Bars object is calling the OnBarUpdate() method 
     if (BarsInProgress == 0) 
     { 
         // A value of zero represents the primary Bars which is the ES 09-14 
         // 1 minute chart. 
         // Do something within the context of the 1 minute Bars here 
     } 
     else if (BarsInProgress == 1) 
     { 
         // A value of 1 represents the secondary 5 minute bars added in OnStateChange() State.Configure 
         // Do something within the context of the 5 minute Bars 
     } 
}
```

#### Example 3

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Add a 5 minute Bars object: BarsInProgress index = 1 
         AddDataSeries(BarsPeriodType.Minute, 5);
     }
} 

protected override void OnBarUpdate() 
{ 
     // Check which Bars object is calling the OnBarUpdate() method 
     if (BarsInProgress == 0) 
     { 
         // A value of zero represents the primary Bars which is the ES 09-14 
         // 1 minute chart. 
         // Do something within the context of the 1 minute Bars here 
     } 
     else if (BarsInProgress == 1) 
     { 
         // A value of 1 represents the secondary 5 minute bars added in OnStateChange() State.Configure 
         // Do something within the context of the 5 minute Bars 
     } 
}
```

---

## 87. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/barsperiods

**Captured:** 2025-07-07T18:21:56.358Z

### Page Structure

- BarsPeriods
  - Definition
  - Property Value
  - Warning
  - Syntax
  - Examples
      - ON THIS PAGE
- BarsPeriods
  - Definition
  - Property Value
  - Warning
  - Syntax
  - Examples
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXBarsPeriodsDefinitionHolds an array of BarsPeriod objects synchronized to the number of unique Bars objects held within the parent NinjaScript object. If a NinjaScript object holds two Bars series, then BarsPeriods will hold two BarsPeriod objects.Property ValueAn array of BarsPeriod objects.WarningThis property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoadedSyntaxBarsPeriods[int barSeriesIndex]Examplesprotected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the strategy and is automatically assigned 
         // a Bars object index of 1 since the original data the strategy is ran on,
         // set by the UI, takes the index of 0. 
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5); 
     }
} 

protected override void OnBarUpdate() 
{ 
     // Print out 5, the value of the secondary bars object 
     if (BarsInProgress == 1)
         Print(BarsPeriods[1].Value);
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamplesBarsPeriodsDefinitionHolds an array of BarsPeriod objects synchronized to the number of unique Bars objects held within the parent NinjaScript object. If a NinjaScript object holds two Bars series, then BarsPeriods will hold two BarsPeriod objects.Property ValueAn array of BarsPeriod objects.WarningThis property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoadedSyntaxBarsPeriods[int barSeriesIndex]Examplesprotected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the strategy and is automatically assigned 
         // a Bars object index of 1 since the original data the strategy is ran on,
         // set by the UI, takes the index of 0. 
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5); 
     }
} 

protected override void OnBarUpdate() 
{ 
     // Print out 5, the value of the secondary bars object 
     if (BarsInProgress == 1)
         Print(BarsPeriods[1].Value);
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamples

### Code Examples

#### Example 1

```csharp
BarsPeriods[int barSeriesIndex]
```

#### Example 2

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the strategy and is automatically assigned 
         // a Bars object index of 1 since the original data the strategy is ran on,
         // set by the UI, takes the index of 0. 
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5); 
     }
} 

protected override void OnBarUpdate() 
{ 
     // Print out 5, the value of the secondary bars object 
     if (BarsInProgress == 1)
         Print(BarsPeriods[1].Value);
}
```

#### Example 3

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the strategy and is automatically assigned 
         // a Bars object index of 1 since the original data the strategy is ran on,
         // set by the UI, takes the index of 0. 
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5); 
     }
} 

protected override void OnBarUpdate() 
{ 
     // Print out 5, the value of the secondary bars object 
     if (BarsInProgress == 1)
         Print(BarsPeriods[1].Value);
}
```

---

## 88. NinjaTrader Developer Community | NinjaScript Resources & Documentation

**URL:** https://developer.ninjatrader.com/docs/desktop/currentbars

**Captured:** 2025-07-07T18:21:59.357Z

### Page Structure

- CurrentBars
  - Definition
  - Note
  - Property Value
  - Warning
  - Syntax
  - Examples
    - Indicator (BarsRequiredToPlot)
    - Strategy (BarsRequiredToTrade)
      - ON THIS PAGE
- CurrentBars
  - Definition
  - Note
  - Property Value
  - Warning
  - Syntax
  - Examples
    - Indicator (BarsRequiredToPlot)
    - Strategy (BarsRequiredToTrade)
      - ON THIS PAGE

### Content

GUIDESIntroductionNinjaScript Best PracticesDistributionNinjaScript Editor OverviewEducational ResourcesUser-Based Vendor LicensingQuick-Start GuideMigration GuideFAQREFERENCESCommonAddDataSeries()AddHeikenAshi()AddKagi()AddLineBreak()AddPointAndFigure()AddRenko()AddVolumetric()BarsArrayBarsInProgressBarsPeriodsCurrentBarsAlert, Debug, ShareAnalyticalAttributesBarsChartsDrawingInstrumentISeriesOnBarUpdate()OnConnectionStatusUpdate()OnFundamentalData()OnMarketData()OnMarketDepth()OnStateChange()SessionIteratorSimpleFontSystem Indicator MethodsTrading HoursClone()DescriptionDisplayNameIsVisibleNameTriggerCustomEvent()Add OnBars TypeChart StyleDrawing ToolsImport TypeIndicatorMarket Analyzer ColumnOptimization FitnessOptimizerPerformance MetricsShare ServiceStrategySuperDOM ColumnSharpDXCurrentBarsDefinitionHolds an array of int values representing the number of the current bar in a Bars object. An int value is added to this array when calling the AddDataSeries() method. Its purpose is to provide access to the CurrentBar of all Bars objects in a multi-instrument or multi-time frame script.NoteIn multi series processing, the CurrentBars starting value will be -1 until all series have processed the first bar.Property ValueAn array of int values.WarningWarning: This property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoaded.SyntaxCurrentBars[int barSeriesIndex]ExamplesIndicator (BarsRequiredToPlot)protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToPlot)
     // or more bars in both Bars objects before continuing.
     if (CurrentBars[0] < BarsRequiredToPlot || CurrentBars[1] < BarsRequiredToPlot)
         return;

     // Indicator script logic calculation code...

}
Strategy (BarsRequiredToTrade)protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToTrade)
     // or more bars in both Bars objects before continuing.
     if (CurrentBars[0] < BarsRequiredToTrade || CurrentBars[1] < BarsRequiredToTrade)
         return;

     // Strategy script logic calculation code...
}
ON THIS PAGEDefinitionProperty ValueSyntaxExamplesCurrentBarsDefinitionHolds an array of int values representing the number of the current bar in a Bars object. An int value is added to this array when calling the AddDataSeries() method. Its purpose is to provide access to the CurrentBar of all Bars objects in a multi-instrument or multi-time frame script.NoteIn multi series processing, the CurrentBars starting value will be -1 until all series have processed the first bar.Property ValueAn array of int values.WarningWarning: This property should NOT be accessed within the OnStateChange() method before the State has reached State.DataLoaded.SyntaxCurrentBars[int barSeriesIndex]ExamplesIndicator (BarsRequiredToPlot)protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToPlot)
     // or more bars in both Bars objects before continuing.
     if (CurrentBars[0] < BarsRequiredToPlot || CurrentBars[1] < BarsRequiredToPlot)
         return;

     // Indicator script logic calculation code...

}
Strategy (BarsRequiredToTrade)protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToTrade)
     // or more bars in both Bars objects before continuing.
    

[Content truncated...]


### Code Examples

#### Example 1

```csharp
CurrentBars[int barSeriesIndex]
```

#### Example 2

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToPlot)
     // or more bars in both Bars objects before continuing.
     if (CurrentBars[0] < BarsRequiredToPlot || CurrentBars[1] < BarsRequiredToPlot)
         return;

     // Indicator script logic calculation code...

}
```

#### Example 3

```csharp
protected override void OnStateChange()
{
     if (State == State.Configure)
     {
         // Adds a 5-minute Bars object to the script. It will automatically be assigned
         // a Bars object index of 1 since the primary data the indicator is run against
         // set by the UI takes the index of 0.
         AddDataSeries("AAPL", BarsPeriodType.Minute, 5);
     }
}

protected override void OnBarUpdate()
{
     // Evaluates to make sure we have at least 20 (default value of BarsRequiredToPlot)
     // or more bars in both Bars objects before continuing.
     if (CurrentBars[0] < BarsRequiredToPlot || CurrentBars[1] < BarsRequiredToPlot)
         return;

     // Indicator script logic calculation code...

}
```

---

